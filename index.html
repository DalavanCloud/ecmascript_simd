<!doctype html>
<head><meta charset="utf-8">
<title>SIMD.js specification v0.9</title>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="ecmarkup.js"></script>
<script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Introduction","titleHTML":"Introduction","number":"","namespace":"<no location>","location":"","referencingIds":[],"key":"Introduction"},{"type":"clause","id":"primitive-def","aoid":null,"title":"primitive value (4.3.2)","titleHTML":"primitive value (<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-primitive-value\">4.3.2</a>)","number":"1.1","namespace":"<no location>","location":"","referencingIds":[],"key":"primitive value (4.3.2)"},{"type":"clause","id":"simd-meta-var-def","aoid":null,"title":"SIMD","titleHTML":"<var>SIMD</var>","number":"1.2","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD"},{"type":"clause","id":"simd-meta-var-def","aoid":null,"title":"SIMDDescriptor","titleHTML":"<var>SIMD</var>Descriptor","number":"1.3","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDDescriptor"},{"type":"clause","id":"simd-type-def","aoid":null,"title":"SIMD types","titleHTML":"SIMD types","number":"1.4","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD types"},{"type":"op","aoid":"SIMD value","refId":"simd-value-def","location":"","referencingIds":[],"key":"SIMD value"},{"type":"clause","id":"simd-value-def","aoid":"SIMD value","title":"SIMD value","titleHTML":"SIMD value","number":"1.5","namespace":"<no location>","location":"","referencingIds":["_ref_40","_ref_41","_ref_42","_ref_43","_ref_122","_ref_323"],"key":"SIMD value"},{"type":"op","aoid":"SIMD object","refId":"simd-object-def","location":"","referencingIds":[],"key":"SIMD object"},{"type":"clause","id":"simd-object-def","aoid":"SIMD object","title":"SIMD object","titleHTML":"SIMD object","number":"1.6","namespace":"<no location>","location":"","referencingIds":["_ref_11","_ref_119","_ref_120","_ref_206"],"key":"SIMD object"},{"type":"clause","id":"simd-type-descriptor-def","aoid":null,"title":"SIMD type descriptor","titleHTML":"SIMD type descriptor","number":"1.7","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD type descriptor"},{"type":"clause","id":"simd-boolean-type","aoid":null,"title":"SIMD boolean type","titleHTML":"SIMD boolean type","number":"1.8","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD boolean type"},{"type":"clause","id":"simd-integer-type","aoid":null,"title":"SIMD integer type","titleHTML":"SIMD integer type","number":"1.9","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD integer type"},{"type":"clause","id":"simd-floating-point-type","aoid":null,"title":"SIMD floating-point type","titleHTML":"SIMD floating-point type","number":"1.10","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD floating-point type"},{"type":"clause","id":"simd-signed-integer-type","aoid":null,"title":"SIMD signed integer type","titleHTML":"SIMD signed integer type","number":"1.11","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD signed integer type"},{"type":"clause","id":"simd-unsigned-integer-type","aoid":null,"title":"SIMD unsigned integer type","titleHTML":"SIMD unsigned integer type","number":"1.12","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD unsigned integer type"},{"type":"clause","id":"terms-and-defs","aoid":null,"title":"Terms and definitions (4.3)","titleHTML":"Terms and definitions (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values\">4.3</a>)","number":"1","namespace":"<no location>","location":"","referencingIds":[],"key":"Terms and definitions (4.3)"},{"type":"clause","id":"intrinsics","aoid":null,"title":"Well-Known Intrinsic Objects (6.1.7.4)","titleHTML":"Well-Known Intrinsic Objects (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-well-known-intrinsic-objects\">6.1.7.4</a>)","number":"2.1.1.1","namespace":"<no location>","location":"","referencingIds":[],"key":"Well-Known Intrinsic Objects (6.1.7.4)"},{"type":"clause","id":"object-type","aoid":null,"title":"The Object Type (6.1.7)","titleHTML":"The Object Type (<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object-type\">6.1.7</a>)","number":"2.1.1","namespace":"<no location>","location":"","referencingIds":[],"key":"The Object Type (6.1.7)"},{"type":"clause","id":"all-types","aoid":null,"title":"ECMAScript language types (6.1)","titleHTML":"ECMAScript language types (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types\">6.1</a>)","number":"2.1","namespace":"<no location>","location":"","referencingIds":[],"key":"ECMAScript language types (6.1)"},{"type":"op","aoid":"Float32x4","refId":"float32x4","location":"","referencingIds":[],"key":"Float32x4"},{"type":"clause","id":"float32x4","aoid":"Float32x4","title":"Float32x4","titleHTML":"Float32x4","number":"2.2.1","namespace":"<no location>","location":"","referencingIds":["_ref_0","_ref_1","_ref_13","_ref_23","_ref_33","_ref_109","_ref_196","_ref_207","_ref_324"],"key":"Float32x4"},{"type":"op","aoid":"Int32x4","refId":"int32x4","location":"","referencingIds":[],"key":"Int32x4"},{"type":"clause","id":"int32x4","aoid":"Int32x4","title":"Int32x4","titleHTML":"Int32x4","number":"2.2.2","namespace":"<no location>","location":"","referencingIds":["_ref_2","_ref_14","_ref_27","_ref_34","_ref_110","_ref_197","_ref_274","_ref_279","_ref_328"],"key":"Int32x4"},{"type":"op","aoid":"Int16x8","refId":"int16x8","location":"","referencingIds":[],"key":"Int16x8"},{"type":"clause","id":"int16x8","aoid":"Int16x8","title":"Int16x8","titleHTML":"Int16x8","number":"2.2.3","namespace":"<no location>","location":"","referencingIds":["_ref_3","_ref_15","_ref_28","_ref_35","_ref_111","_ref_198","_ref_332"],"key":"Int16x8"},{"type":"op","aoid":"Int8x16","refId":"int8x16","location":"","referencingIds":[],"key":"Int8x16"},{"type":"clause","id":"int8x16","aoid":"Int8x16","title":"Int8x16","titleHTML":"Int8x16","number":"2.2.4","namespace":"<no location>","location":"","referencingIds":["_ref_4","_ref_16","_ref_29","_ref_36","_ref_112","_ref_199","_ref_336"],"key":"Int8x16"},{"type":"op","aoid":"Uint32x4","refId":"uint32x4","location":"","referencingIds":[],"key":"Uint32x4"},{"type":"clause","id":"uint32x4","aoid":"Uint32x4","title":"Uint32x4","titleHTML":"Uint32x4","number":"2.2.5","namespace":"<no location>","location":"","referencingIds":["_ref_5","_ref_17","_ref_30","_ref_37","_ref_113","_ref_200","_ref_273","_ref_278","_ref_340"],"key":"Uint32x4"},{"type":"op","aoid":"Uint16x8","refId":"uint16x8","location":"","referencingIds":[],"key":"Uint16x8"},{"type":"clause","id":"uint16x8","aoid":"Uint16x8","title":"Uint16x8","titleHTML":"Uint16x8","number":"2.2.6","namespace":"<no location>","location":"","referencingIds":["_ref_6","_ref_18","_ref_31","_ref_38","_ref_114","_ref_201","_ref_344"],"key":"Uint16x8"},{"type":"op","aoid":"Uint8x16","refId":"uint8x16","location":"","referencingIds":[],"key":"Uint8x16"},{"type":"clause","id":"uint8x16","aoid":"Uint8x16","title":"Uint8x16","titleHTML":"Uint8x16","number":"2.2.7","namespace":"<no location>","location":"","referencingIds":["_ref_7","_ref_19","_ref_32","_ref_39","_ref_115","_ref_202","_ref_348"],"key":"Uint8x16"},{"type":"op","aoid":"Bool32x4","refId":"bool32x4","location":"","referencingIds":[],"key":"Bool32x4"},{"type":"clause","id":"bool32x4","aoid":"Bool32x4","title":"Bool32x4","titleHTML":"Bool32x4","number":"2.2.8","namespace":"<no location>","location":"","referencingIds":["_ref_8","_ref_20","_ref_24","_ref_116","_ref_203","_ref_352"],"key":"Bool32x4"},{"type":"op","aoid":"Bool16x8","refId":"bool16x8","location":"","referencingIds":[],"key":"Bool16x8"},{"type":"clause","id":"bool16x8","aoid":"Bool16x8","title":"Bool16x8","titleHTML":"Bool16x8","number":"2.2.9","namespace":"<no location>","location":"","referencingIds":["_ref_9","_ref_21","_ref_25","_ref_117","_ref_204","_ref_354"],"key":"Bool16x8"},{"type":"op","aoid":"Bool8x16","refId":"bool8x16","location":"","referencingIds":[],"key":"Bool8x16"},{"type":"clause","id":"bool8x16","aoid":"Bool8x16","title":"Bool8x16","titleHTML":"Bool8x16","number":"2.2.10","namespace":"<no location>","location":"","referencingIds":["_ref_10","_ref_22","_ref_26","_ref_118","_ref_205","_ref_356"],"key":"Bool8x16"},{"type":"clause","id":"simd-types","aoid":null,"title":"SIMD types","titleHTML":"SIMD types","number":"2.2","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD types"},{"type":"clause","id":"types","aoid":null,"title":"ECMAScript Data Types and Values (6)","titleHTML":"ECMAScript Data Types and Values (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values\">6</a>)","number":"2","namespace":"<no location>","location":"","referencingIds":[],"key":"ECMAScript Data Types and Values (6)"},{"type":"clause","id":"to-primitive","aoid":null,"title":"ToPrimitive ( input [, PreferredType] ) (7.1.1)","titleHTML":"ToPrimitive ( input [, PreferredType] ) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive\">7.1.1</a>)","number":"3.1.1","namespace":"<no location>","location":"","referencingIds":[],"key":"ToPrimitive ( input [, PreferredType] ) (7.1.1)"},{"type":"clause","id":"to-boolean","aoid":null,"title":"ToBoolean ( argument ) (7.1.2)","titleHTML":"ToBoolean ( argument ) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-toboolean\">7.1.2</a>)","number":"3.1.2","namespace":"<no location>","location":"","referencingIds":[],"key":"ToBoolean ( argument ) (7.1.2)"},{"type":"clause","id":"to-number","aoid":null,"title":"ToNumber ( argument ) (7.1.3)","titleHTML":"ToNumber ( argument ) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber\">7.1.3</a>)","number":"3.1.3","namespace":"<no location>","location":"","referencingIds":[],"key":"ToNumber ( argument ) (7.1.3)"},{"type":"clause","id":"to-string","aoid":null,"title":"ToString ( argument ) (7.1.12)","titleHTML":"ToString ( argument ) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\">7.1.12</a>)","number":"3.1.4","namespace":"<no location>","location":"","referencingIds":[],"key":"ToString ( argument ) (7.1.12)"},{"type":"clause","id":"to-object","aoid":null,"title":"ToObject ( argument ) (7.1.13)","titleHTML":"ToObject ( argument ) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-toobject\">7.1.13</a>)","number":"3.1.5","namespace":"<no location>","location":"","referencingIds":[],"key":"ToObject ( argument ) (7.1.13)"},{"type":"clause","id":"type-conversion","aoid":null,"title":"Type Conversion (7.1)","titleHTML":"Type Conversion (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-type-conversion\">7.1</a>)","number":"3.1","namespace":"<no location>","location":"","referencingIds":[],"key":"Type Conversion (7.1)"},{"type":"clause","id":"require-object-coercible","aoid":null,"title":"RequireObjectCoercible ( argument ) (7.2.1)","titleHTML":"RequireObjectCoercible ( argument ) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-requireobjectcoercible\">7.2.1</a>)","number":"3.2","namespace":"<no location>","location":"","referencingIds":[],"key":"RequireObjectCoercible ( argument ) (7.2.1)"},{"type":"clause","id":"same-value","aoid":null,"title":"SameValue(x, y) (7.2.9)","titleHTML":"SameValue(x, y) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-samevalue\">7.2.9</a>)","number":"3.3","namespace":"<no location>","location":"","referencingIds":[],"key":"SameValue(x, y) (7.2.9)"},{"type":"clause","id":"same-value-zero","aoid":null,"title":"SameValueZero(x, y) (7.2.10)","titleHTML":"SameValueZero(x, y) (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero\">7.2.10</a>)","number":"3.4","namespace":"<no location>","location":"","referencingIds":[],"key":"SameValueZero(x, y) (7.2.10)"},{"type":"clause","id":"abstract-equality","aoid":null,"title":"Abstract Equality Comparison (7.2.12)","titleHTML":"Abstract Equality Comparison (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison\">7.2.12</a>)","number":"3.5","namespace":"<no location>","location":"","referencingIds":[],"key":"Abstract Equality Comparison (7.2.12)"},{"type":"clause","id":"strict-equality-comparison","aoid":null,"title":"Strict Equality Comparison (7.2.13)","titleHTML":"Strict Equality Comparison (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison\">7.2.13</a>)","number":"3.6","namespace":"<no location>","location":"","referencingIds":[],"key":"Strict Equality Comparison (7.2.13)"},{"type":"clause","id":"abstract-operations","aoid":null,"title":"Abstract Operations (7)","titleHTML":"Abstract Operations (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-operations\">7</a>)","number":"3","namespace":"<no location>","location":"","referencingIds":[],"key":"Abstract Operations (7)"},{"type":"clause","id":"typeof-evaluation","aoid":null,"title":"Runtime Semantics: Evaluation (12.5.6.1)","titleHTML":"Runtime Semantics: Evaluation (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation\">12.5.6.1</a>)","number":"4.1","namespace":"<no location>","location":"","referencingIds":[],"key":"Runtime Semantics: Evaluation (12.5.6.1)"},{"type":"clause","id":"typeof","aoid":null,"title":"The typeof Operator (12.5.6)","titleHTML":"The typeof Operator (<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator\">12.5.6</a>)","number":"4","namespace":"<no location>","location":"","referencingIds":[],"key":"The typeof Operator (12.5.6)"},{"type":"op","aoid":"SIMDCreate","refId":"simd-create","location":"","referencingIds":[],"key":"SIMDCreate"},{"type":"clause","id":"simd-create","aoid":"SIMDCreate","title":"SIMDCreate( descriptor, vectorElements )","titleHTML":"SIMDCreate( descriptor, vectorElements )","number":"5.1.1","namespace":"<no location>","location":"","referencingIds":["_ref_133","_ref_140","_ref_146","_ref_150","_ref_208","_ref_209","_ref_269","_ref_301","_ref_305","_ref_310"],"key":"SIMDCreate( descriptor, vectorElements )"},{"type":"op","aoid":"SIMDToLane","refId":"simd-to-lane","location":"","referencingIds":[],"key":"SIMDToLane"},{"type":"clause","id":"simd-to-lane","aoid":"SIMDToLane","title":"SIMDToLane( max, lane )","titleHTML":"SIMDToLane( max, lane )","number":"5.1.2","namespace":"<no location>","location":"","referencingIds":["_ref_128","_ref_131","_ref_302","_ref_306"],"key":"SIMDToLane( max, lane )"},{"type":"op","aoid":"SIMDExtractLane","refId":"simd-abstract-extract-lane","location":"","referencingIds":[],"key":"SIMDExtractLane"},{"type":"clause","id":"simd-abstract-extract-lane","aoid":"SIMDExtractLane","title":"SIMDExtractLane( value, lane )","titleHTML":"SIMDExtractLane( value, lane )","number":"5.1.3","namespace":"<no location>","location":"","referencingIds":["_ref_58","_ref_59","_ref_73","_ref_74","_ref_107","_ref_108","_ref_135","_ref_137","_ref_142","_ref_148","_ref_289","_ref_304","_ref_308","_ref_309"],"key":"SIMDExtractLane( value, lane )"},{"type":"op","aoid":"SIMDReplaceLane","refId":"simd-abstract-replace-lane","location":"","referencingIds":[],"key":"SIMDReplaceLane"},{"type":"clause","id":"simd-abstract-replace-lane","aoid":"SIMDReplaceLane","title":"SIMDReplaceLane( value, lane, replacement )","titleHTML":"SIMDReplaceLane( value, lane, replacement )","number":"5.1.4","namespace":"<no location>","location":"","referencingIds":["_ref_290"],"key":"SIMDReplaceLane( value, lane, replacement )"},{"type":"op","aoid":"MaybeFlushDenormal","refId":"maybe-flush-denormal","location":"","referencingIds":[],"key":"MaybeFlushDenormal"},{"type":"clause","id":"maybe-flush-denormal","aoid":"MaybeFlushDenormal","title":"MaybeFlushDenormal( n, descriptor )","titleHTML":"MaybeFlushDenormal( n, descriptor )","number":"5.1.5","namespace":"<no location>","location":"","referencingIds":["_ref_134","_ref_136","_ref_139","_ref_143","_ref_145"],"key":"MaybeFlushDenormal( n, descriptor )"},{"type":"op","aoid":"SIMDBinaryOp","refId":"simd-binary","location":"","referencingIds":[],"key":"SIMDBinaryOp"},{"type":"clause","id":"simd-binary","aoid":"SIMDBinaryOp","title":"SIMDBinaryOp( a, b, op, outputDescriptor )","titleHTML":"SIMDBinaryOp( a, b, op, outputDescriptor )","number":"5.1.6","namespace":"<no location>","location":"","referencingIds":["_ref_162","_ref_210","_ref_212","_ref_215","_ref_217","_ref_219","_ref_221","_ref_224","_ref_227","_ref_244","_ref_247","_ref_250","_ref_270","_ref_275"],"key":"SIMDBinaryOp( a, b, op, outputDescriptor )"},{"type":"op","aoid":"SIMDUnaryOp","refId":"simd-unary","location":"","referencingIds":[],"key":"SIMDUnaryOp"},{"type":"clause","id":"simd-unary","aoid":"SIMDUnaryOp","title":"SIMDUnaryOp( a, op [ , flushDenormal ] )","titleHTML":"SIMDUnaryOp( a, op [ , flushDenormal ] )","number":"5.1.7","namespace":"<no location>","location":"","referencingIds":["_ref_230","_ref_232","_ref_235","_ref_238","_ref_241","_ref_253"],"key":"SIMDUnaryOp( a, op [ , flushDenormal ] )"},{"type":"op","aoid":"SIMDScalarOp","refId":"simd-scalar","location":"","referencingIds":[],"key":"SIMDScalarOp"},{"type":"clause","id":"simd-scalar","aoid":"SIMDScalarOp","title":"SIMDScalarOp( a, scalar, op )","titleHTML":"SIMDScalarOp( a, scalar, op )","number":"5.1.8","namespace":"<no location>","location":"","referencingIds":["_ref_281","_ref_284","_ref_287"],"key":"SIMDScalarOp( a, scalar, op )"},{"type":"op","aoid":"SIMDLoad","refId":"simd-load","location":"","referencingIds":[],"key":"SIMDLoad"},{"type":"clause","id":"simd-load","aoid":"SIMDLoad","title":"SIMDLoad( dataBlock, descriptor, byteOffset [, length] )","titleHTML":"SIMDLoad( dataBlock, descriptor, byteOffset [, length] )","number":"5.1.9","namespace":"<no location>","location":"","referencingIds":["_ref_153","_ref_160"],"key":"SIMDLoad( dataBlock, descriptor, byteOffset [, length] )"},{"type":"op","aoid":"SIMDLoadFromTypedArray","refId":"simd-load-from-tarray","location":"","referencingIds":[],"key":"SIMDLoadFromTypedArray"},{"type":"clause","id":"simd-load-from-tarray","aoid":"SIMDLoadFromTypedArray","title":"SIMDLoadFromTypedArray( tarray, index, descriptor [, length] )","titleHTML":"SIMDLoadFromTypedArray( tarray, index, descriptor [, length] )","number":"5.1.10","namespace":"<no location>","location":"","referencingIds":["_ref_295","_ref_296","_ref_297","_ref_298"],"key":"SIMDLoadFromTypedArray( tarray, index, descriptor [, length] )"},{"type":"op","aoid":"SIMDStore","refId":"simd-store","location":"","referencingIds":[],"key":"SIMDStore"},{"type":"clause","id":"simd-store","aoid":"SIMDStore","title":"SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )","titleHTML":"SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )","number":"5.1.11","namespace":"<no location>","location":"","referencingIds":["_ref_156","_ref_159"],"key":"SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )"},{"type":"op","aoid":"SIMDStoreInTypedArray","refId":"simd-store-in-tarray","location":"","referencingIds":[],"key":"SIMDStoreInTypedArray"},{"type":"clause","id":"simd-store-in-tarray","aoid":"SIMDStoreInTypedArray","title":"SIMDStoreInTypedArray( tarray, index, descriptor, n [, length] )","titleHTML":"SIMDStoreInTypedArray( tarray, index, descriptor, n [, length] )","number":"5.1.12","namespace":"<no location>","location":"","referencingIds":["_ref_291","_ref_292","_ref_293","_ref_294"],"key":"SIMDStoreInTypedArray( tarray, index, descriptor, n [, length] )"},{"type":"op","aoid":"SIMDReinterpretCast","refId":"simd-reinterpret-cast","location":"","referencingIds":[],"key":"SIMDReinterpretCast"},{"type":"clause","id":"simd-reinterpret-cast","aoid":"SIMDReinterpretCast","title":"SIMDReinterpretCast( value, newDescriptor )","titleHTML":"SIMDReinterpretCast( value, newDescriptor )","number":"5.1.13","namespace":"<no location>","location":"","referencingIds":["_ref_299"],"key":"SIMDReinterpretCast( value, newDescriptor )"},{"type":"op","aoid":"SIMDBoolType","refId":"simd-int-type","location":"","referencingIds":[],"key":"SIMDBoolType"},{"type":"clause","id":"simd-int-type","aoid":"SIMDBoolType","title":"SIMDBoolType( descriptor )","titleHTML":"SIMDBoolType( descriptor )","number":"5.1.14","namespace":"<no location>","location":"","referencingIds":["_ref_161","_ref_268"],"key":"SIMDBoolType( descriptor )"},{"type":"op","aoid":"SIMDRelationalOp","refId":"simd-relational-op","location":"","referencingIds":[],"key":"SIMDRelationalOp"},{"type":"clause","id":"simd-relational-op","aoid":"SIMDRelationalOp","title":"SIMDRelationalOp( a, b, op )","titleHTML":"SIMDRelationalOp( a, b, op )","number":"5.1.15","namespace":"<no location>","location":"","referencingIds":["_ref_255","_ref_257","_ref_258","_ref_260","_ref_262","_ref_264","_ref_266"],"key":"SIMDRelationalOp( a, b, op )"},{"type":"op","aoid":"MathAbs","refId":"abs","location":"","referencingIds":[],"key":"MathAbs"},{"type":"clause","id":"abs","aoid":"MathAbs","title":"MathAbs( x )","titleHTML":"MathAbs( x )","number":"5.1.16","namespace":"<no location>","location":"","referencingIds":[],"key":"MathAbs( x )"},{"type":"op","aoid":"ToFloat32","refId":"fround","location":"","referencingIds":[],"key":"ToFloat32"},{"type":"clause","id":"fround","aoid":"ToFloat32","title":"ToFloat32( argument )","titleHTML":"ToFloat32( argument )","number":"5.1.17","namespace":"<no location>","location":"","referencingIds":["_ref_325"],"key":"ToFloat32( argument )"},{"type":"op","aoid":"MathSqrt","refId":"abs","location":"","referencingIds":[],"key":"MathSqrt"},{"type":"clause","id":"abs","aoid":"MathSqrt","title":"MathSqrt( x )","titleHTML":"MathSqrt( x )","number":"5.1.18","namespace":"<no location>","location":"","referencingIds":["_ref_233","_ref_242"],"key":"MathSqrt( x )"},{"type":"op","aoid":"MathImul","refId":"imul","location":"","referencingIds":[],"key":"MathImul"},{"type":"clause","id":"imul","aoid":"MathImul","title":"MathImul(n, m)","titleHTML":"MathImul(n, m)","number":"5.1.19","namespace":"<no location>","location":"","referencingIds":["_ref_214"],"key":"MathImul(n, m)"},{"type":"op","aoid":"MathMin","refId":"min","location":"","referencingIds":[],"key":"MathMin"},{"type":"clause","id":"min","aoid":"MathMin","title":"MathMin(n, m)","titleHTML":"MathMin(n, m)","number":"5.1.20","namespace":"<no location>","location":"","referencingIds":["_ref_174","_ref_222"],"key":"MathMin(n, m)"},{"type":"op","aoid":"MaxNum","refId":"max-num","location":"","referencingIds":[],"key":"MaxNum"},{"type":"clause","id":"max-num","aoid":"MaxNum","title":"MaxNum(n, m)","titleHTML":"MaxNum(n, m)","number":"5.1.21","namespace":"<no location>","location":"","referencingIds":["_ref_225"],"key":"MaxNum(n, m)"},{"type":"op","aoid":"MinNum","refId":"min-num","location":"","referencingIds":[],"key":"MinNum"},{"type":"clause","id":"min-num","aoid":"MinNum","title":"MinNum(n, m)","titleHTML":"MinNum(n, m)","number":"5.1.22","namespace":"<no location>","location":"","referencingIds":["_ref_228"],"key":"MinNum(n, m)"},{"type":"op","aoid":"ReciprocalApproximation","refId":"reciprocal","location":"","referencingIds":[],"key":"ReciprocalApproximation"},{"type":"clause","id":"reciprocal","aoid":"ReciprocalApproximation","title":"ReciprocalApproximation(n)","titleHTML":"ReciprocalApproximation(n)","number":"5.1.23","namespace":"<no location>","location":"","referencingIds":[],"key":"ReciprocalApproximation(n)"},{"type":"op","aoid":"ReciprocalSqrtApproximation","refId":"reciprocal","location":"","referencingIds":[],"key":"ReciprocalSqrtApproximation"},{"type":"clause","id":"reciprocal","aoid":"ReciprocalSqrtApproximation","title":"ReciprocalSqrtApproximation(n)","titleHTML":"ReciprocalSqrtApproximation(n)","number":"5.1.24","namespace":"<no location>","location":"","referencingIds":["_ref_236","_ref_239"],"key":"ReciprocalSqrtApproximation(n)"},{"type":"op","aoid":"Saturate","refId":"saturate","location":"","referencingIds":[],"key":"Saturate"},{"type":"clause","id":"saturate","aoid":"Saturate","title":"Saturate( descriptor, x )","titleHTML":"Saturate( descriptor, x )","number":"5.1.25","namespace":"<no location>","location":"","referencingIds":["_ref_176","_ref_177"],"key":"Saturate( descriptor, x )"},{"type":"op","aoid":"AddSaturate","refId":"add-saturate","location":"","referencingIds":[],"key":"AddSaturate"},{"type":"clause","id":"add-saturate","aoid":"AddSaturate","title":"AddSaturate( descriptor )( x, y )","titleHTML":"AddSaturate( descriptor )( x, y )","number":"5.1.26","namespace":"<no location>","location":"","referencingIds":["_ref_271"],"key":"AddSaturate( descriptor )( x, y )"},{"type":"op","aoid":"SubSaturate","refId":"sub-saturate","location":"","referencingIds":[],"key":"SubSaturate"},{"type":"clause","id":"sub-saturate","aoid":"SubSaturate","title":"SubSaturate( descriptor )( x, y )","titleHTML":"SubSaturate( descriptor )( x, y )","number":"5.1.27","namespace":"<no location>","location":"","referencingIds":["_ref_276"],"key":"SubSaturate( descriptor )( x, y )"},{"type":"op","aoid":"BitwiseOp","refId":"bitwise-op","location":"","referencingIds":[],"key":"BitwiseOp"},{"type":"clause","id":"bitwise-op","aoid":"BitwiseOp","title":"BitwiseOp( @ )( lval, rval )","titleHTML":"BitwiseOp( @ )( lval, rval )","number":"5.1.28","namespace":"<no location>","location":"","referencingIds":["_ref_245","_ref_248","_ref_251"],"key":"BitwiseOp( @ )( lval, rval )"},{"type":"op","aoid":"ArrayJoin","refId":"array-join","location":"","referencingIds":[],"key":"ArrayJoin"},{"type":"clause","id":"array-join","aoid":"ArrayJoin","title":"ArrayJoin( array, separator )","titleHTML":"ArrayJoin( array, separator )","number":"5.1.29","namespace":"<no location>","location":"","referencingIds":["_ref_45","_ref_315"],"key":"ArrayJoin( array, separator )"},{"type":"clause","id":"simd-algorithms","aoid":null,"title":"Internal algorithms on SIMD types","titleHTML":"Internal algorithms on SIMD types","number":"5.1","namespace":"<no location>","location":"","referencingIds":[],"key":"Internal algorithms on SIMD types"},{"type":"clause","id":"simd-wrapper","aoid":null,"title":"SIMDConstructor( ...values )","titleHTML":"<var>SIMD</var>Constructor( ...values )","number":"5.2.1","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor( ...values )"},{"type":"clause","id":"simd-constructor","aoid":null,"title":"Constructor properties SIMDConstructor of the SIMD object","titleHTML":"Constructor properties <var>SIMD</var>Constructor of the SIMD object","number":"5.2","namespace":"<no location>","location":"","referencingIds":[],"key":"Constructor properties SIMDConstructor of the SIMD object"},{"type":"clause","id":"simd-splat","aoid":null,"title":"SIMDConstructor.splat(n)","titleHTML":"<var>SIMD</var>Constructor.splat(n)","number":"5.3.1","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.splat(n)"},{"type":"clause","id":"simd-check","aoid":null,"title":"SIMDConstructor.check(a)","titleHTML":"<var>SIMD</var>Constructor.check(a)","number":"5.3.2","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.check(a)"},{"type":"clause","id":"simd-add","aoid":null,"title":"SIMDConstructor.add(a, b)","titleHTML":"<var>SIMD</var>Constructor.add(a, b)","number":"5.3.3","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.add(a, b)"},{"type":"clause","id":"simd-sub","aoid":null,"title":"SIMDConstructor.sub(a, b)","titleHTML":"<var>SIMD</var>Constructor.sub(a, b)","number":"5.3.4","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.sub(a, b)"},{"type":"clause","id":"simd-mul","aoid":null,"title":"SIMDConstructor.mul(a, b)","titleHTML":"<var>SIMD</var>Constructor.mul(a, b)","number":"5.3.5","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.mul(a, b)"},{"type":"clause","id":"simd-div","aoid":null,"title":"SIMDConstructor.div(a, b)","titleHTML":"<var>SIMD</var>Constructor.div(a, b)","number":"5.3.6","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.div(a, b)"},{"type":"clause","id":"simd-max","aoid":null,"title":"SIMDConstructor.max(a, b)","titleHTML":"<var>SIMD</var>Constructor.max(a, b)","number":"5.3.7","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.max(a, b)"},{"type":"clause","id":"simd-min","aoid":null,"title":"SIMDConstructor.min(a, b)","titleHTML":"<var>SIMD</var>Constructor.min(a, b)","number":"5.3.8","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.min(a, b)"},{"type":"clause","id":"simd-max-num","aoid":null,"title":"SIMDConstructor.maxNum(a, b)","titleHTML":"<var>SIMD</var>Constructor.maxNum(a, b)","number":"5.3.9","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.maxNum(a, b)"},{"type":"clause","id":"simd-min-num","aoid":null,"title":"SIMDConstructor.minNum(a, b)","titleHTML":"<var>SIMD</var>Constructor.minNum(a, b)","number":"5.3.10","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.minNum(a, b)"},{"type":"clause","id":"simd-neg","aoid":null,"title":"SIMDConstructor.neg(a)","titleHTML":"<var>SIMD</var>Constructor.neg(a)","number":"5.3.11","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.neg(a)"},{"type":"clause","id":"simd-sqrt","aoid":null,"title":"SIMDConstructor.sqrt(a)","titleHTML":"<var>SIMD</var>Constructor.sqrt(a)","number":"5.3.12","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.sqrt(a)"},{"type":"clause","id":"simd-reciprocal-approximation","aoid":null,"title":"SIMDConstructor.reciprocalApproximation(a)","titleHTML":"<var>SIMD</var>Constructor.reciprocalApproximation(a)","number":"5.3.13","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.reciprocalApproximation(a)"},{"type":"clause","id":"simd-reciprocal-sqrt-approximation","aoid":null,"title":"SIMDConstructor.reciprocalSqrtApproximation(a)","titleHTML":"<var>SIMD</var>Constructor.reciprocalSqrtApproximation(a)","number":"5.3.14","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.reciprocalSqrtApproximation(a)"},{"type":"clause","id":"simd-abs","aoid":null,"title":"SIMDConstructor.abs(a)","titleHTML":"<var>SIMD</var>Constructor.abs(a)","number":"5.3.15","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.abs(a)"},{"type":"clause","id":"simd-and","aoid":null,"title":"SIMDConstructor.and(a, b)","titleHTML":"<var>SIMD</var>Constructor.and(a, b)","number":"5.3.16","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.and(a, b)"},{"type":"clause","id":"simd-xor","aoid":null,"title":"SIMDConstructor.xor(a, b)","titleHTML":"<var>SIMD</var>Constructor.xor(a, b)","number":"5.3.17","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.xor(a, b)"},{"type":"clause","id":"simd-or","aoid":null,"title":"SIMDConstructor.or(a, b)","titleHTML":"<var>SIMD</var>Constructor.or(a, b)","number":"5.3.18","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.or(a, b)"},{"type":"clause","id":"simd-not","aoid":null,"title":"SIMDConstructor.not(a)","titleHTML":"<var>SIMD</var>Constructor.not(a)","number":"5.3.19","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.not(a)"},{"type":"clause","id":"simd-less-than","aoid":null,"title":"SIMDConstructor.lessThan(a, b)","titleHTML":"<var>SIMD</var>Constructor.lessThan(a, b)","number":"5.3.20","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.lessThan(a, b)"},{"type":"clause","id":"simd-less-than-or-equal","aoid":null,"title":"SIMDConstructor.lessThanOrEqual(a, b)","titleHTML":"<var>SIMD</var>Constructor.lessThanOrEqual(a, b)","number":"5.3.21","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.lessThanOrEqual(a, b)"},{"type":"clause","id":"simd-greater-than","aoid":null,"title":"SIMDConstructor.greaterThan(a, b)","titleHTML":"<var>SIMD</var>Constructor.greaterThan(a, b)","number":"5.3.22","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.greaterThan(a, b)"},{"type":"clause","id":"simd-greater-than-or-equal","aoid":null,"title":"SIMDConstructor.greaterThanOrEqual(a, b)","titleHTML":"<var>SIMD</var>Constructor.greaterThanOrEqual(a, b)","number":"5.3.23","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.greaterThanOrEqual(a, b)"},{"type":"clause","id":"simd-equal","aoid":null,"title":"SIMDConstructor.equal(a, b)","titleHTML":"<var>SIMD</var>Constructor.equal(a, b)","number":"5.3.24","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.equal(a, b)"},{"type":"clause","id":"simd-not-equal","aoid":null,"title":"SIMDConstructor.notEqual(a, b)","titleHTML":"<var>SIMD</var>Constructor.notEqual(a, b)","number":"5.3.25","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.notEqual(a, b)"},{"type":"clause","id":"simd-any-true","aoid":null,"title":"SIMDConstructor.anyTrue(a)","titleHTML":"<var>SIMD</var>Constructor.anyTrue(a)","number":"5.3.26","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.anyTrue(a)"},{"type":"clause","id":"simd-all-true","aoid":null,"title":"SIMDConstructor.allTrue(a)","titleHTML":"<var>SIMD</var>Constructor.allTrue(a)","number":"5.3.27","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.allTrue(a)"},{"type":"clause","id":"simd-select","aoid":null,"title":"SIMDConstructor.select( selector, a, b )","titleHTML":"<var>SIMD</var>Constructor.select( selector, a, b )","number":"5.3.28","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.select( selector, a, b )"},{"type":"clause","id":"simd-add-saturate","aoid":null,"title":"SIMDConstructor.addSaturate( a, b )","titleHTML":"<var>SIMD</var>Constructor.addSaturate( a, b )","number":"5.3.29","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.addSaturate( a, b )"},{"type":"clause","id":"simd-sub-saturate","aoid":null,"title":"SIMDConstructor.subSaturate( a, b )","titleHTML":"<var>SIMD</var>Constructor.subSaturate( a, b )","number":"5.3.30","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.subSaturate( a, b )"},{"type":"clause","id":"simd-shift-left-by-scalar","aoid":null,"title":"SIMDConstructor.shiftLeftByScalar( a, bits )","titleHTML":"<var>SIMD</var>Constructor.shiftLeftByScalar( a, bits )","number":"5.3.31","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.shiftLeftByScalar( a, bits )"},{"type":"clause","id":"simd-shift-right-by-scalar","aoid":null,"title":"SIMDConstructor.shiftRightByScalar( a, bits )","titleHTML":"<var>SIMD</var>Constructor.shiftRightByScalar( a, bits )","number":"5.3.32","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.shiftRightByScalar( a, bits )"},{"type":"clause","id":"simd-extract-lane","aoid":null,"title":"SIMDConstructor.extractLane( simd, lane )","titleHTML":"<var>SIMD</var>Constructor.extractLane( simd, lane )","number":"5.3.33","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.extractLane( simd, lane )"},{"type":"clause","id":"simd-replace-lane","aoid":null,"title":"SIMDConstructor.replaceLane( simd, lane, value )","titleHTML":"<var>SIMD</var>Constructor.replaceLane( simd, lane, value )","number":"5.3.34","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.replaceLane( simd, lane, value )"},{"type":"clause","id":"simd-store-function","aoid":null,"title":"SIMDConstructor.store( tarray, index, simd )","titleHTML":"<var>SIMD</var>Constructor.store( tarray, index, simd )","number":"5.3.35","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.store( tarray, index, simd )"},{"type":"clause","id":"simd-store1","aoid":null,"title":"SIMDConstructor.store1( tarray, index, simd )","titleHTML":"<var>SIMD</var>Constructor.store1( tarray, index, simd )","number":"5.3.36","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.store1( tarray, index, simd )"},{"type":"clause","id":"simd-store2","aoid":null,"title":"SIMDConstructor.store2( tarray, index, simd )","titleHTML":"<var>SIMD</var>Constructor.store2( tarray, index, simd )","number":"5.3.37","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.store2( tarray, index, simd )"},{"type":"clause","id":"simd-store3","aoid":null,"title":"SIMDConstructor.store3( tarray, index, simd )","titleHTML":"<var>SIMD</var>Constructor.store3( tarray, index, simd )","number":"5.3.38","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.store3( tarray, index, simd )"},{"type":"clause","id":"simd-load-function","aoid":null,"title":"SIMDConstructor.load( tarray, index )","titleHTML":"<var>SIMD</var>Constructor.load( tarray, index )","number":"5.3.39","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.load( tarray, index )"},{"type":"clause","id":"simd-load1","aoid":null,"title":"SIMDConstructor.load1(tarray, index)","titleHTML":"<var>SIMD</var>Constructor.load1(tarray, index)","number":"5.3.40","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.load1(tarray, index)"},{"type":"clause","id":"simd-load2","aoid":null,"title":"SIMDConstructor.load2(tarray, index)","titleHTML":"<var>SIMD</var>Constructor.load2(tarray, index)","number":"5.3.41","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.load2(tarray, index)"},{"type":"clause","id":"simd-load3","aoid":null,"title":"SIMDConstructor.load3(tarray, index)","titleHTML":"<var>SIMD</var>Constructor.load3(tarray, index)","number":"5.3.42","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.load3(tarray, index)"},{"type":"clause","id":"simd-to-timd","aoid":null,"title":"SIMDConstructor.fromTIMDBits( value )","titleHTML":"<var>SIMD</var>Constructor.from<var>TIMD</var>Bits( value )","number":"5.3.43","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.fromTIMDBits( value )"},{"type":"clause","id":"simd-to-timd-logical","aoid":null,"title":"SIMDConstructor.fromTIMD( value )","titleHTML":"<var>SIMD</var>Constructor.from<var>TIMD</var>( value )","number":"5.3.44","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.fromTIMD( value )"},{"type":"clause","id":"swizzle","aoid":null,"title":"SIMDConstructor.swizzle( a, ...lanes )","titleHTML":"<var>SIMD</var>Constructor.swizzle( a, ...lanes )","number":"5.3.45","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.swizzle( a, ...lanes )"},{"type":"clause","id":"shuffle","aoid":null,"title":"SIMDConstructor.shuffle( a, b, ...lanes )","titleHTML":"<var>SIMD</var>Constructor.shuffle( a, b, ...lanes )","number":"5.3.46","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.shuffle( a, b, ...lanes )"},{"type":"clause","id":"constructor-properties","aoid":null,"title":"Properties of the SIMDConstructor constructors","titleHTML":"Properties of the <var>SIMD</var>Constructor constructors","number":"5.3","namespace":"<no location>","location":"","referencingIds":[],"key":"Properties of the SIMDConstructor constructors"},{"type":"clause","id":"simd-proto-constructor","aoid":null,"title":"SIMDConstructor.prototype.constructor","titleHTML":"<var>SIMD</var>Constructor.prototype.constructor","number":"5.4.1","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.prototype.constructor"},{"type":"clause","id":"simd-prototype-valueof","aoid":null,"title":"SIMDConstructor.prototype.valueOf()","titleHTML":"<var>SIMD</var>Constructor.prototype.valueOf()","number":"5.4.2","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.prototype.valueOf()"},{"type":"clause","id":"simd-prototype-tolocalestring","aoid":null,"title":"SIMDConstructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )","titleHTML":"<var>SIMD</var>Constructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )","number":"5.4.3","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )"},{"type":"clause","id":"simd-prototype-tostring","aoid":null,"title":"SIMDConstructor.prototype.toString()","titleHTML":"<var>SIMD</var>Constructor.prototype.toString()","number":"5.4.4","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.prototype.toString()"},{"type":"clause","id":"simd-to-string-tag","aoid":null,"title":"SIMDConstructor.prototype [ @@toStringTag ]","titleHTML":"<var>SIMD</var>Constructor.prototype [ @@toStringTag ]","number":"5.4.5","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.prototype [ @@toStringTag ]"},{"type":"clause","id":"simd-to-primitive","aoid":null,"title":"SIMDConstructor.prototype [ @@toPrimitive ] ( hint )","titleHTML":"<var>SIMD</var>Constructor.prototype [ @@toPrimitive ] ( hint )","number":"5.4.6","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMDConstructor.prototype [ @@toPrimitive ] ( hint )"},{"type":"clause","id":"simd-proto","aoid":null,"title":"The SIMDConstructor.prototype","titleHTML":"The <var>SIMD</var>Constructor.prototype","number":"5.4","namespace":"<no location>","location":"","referencingIds":[],"key":"The SIMDConstructor.prototype"},{"type":"op","aoid":"SerializeFloat32","refId":"serialize-float32","location":"","referencingIds":[],"key":"SerializeFloat32"},{"type":"clause","id":"serialize-float32","aoid":"SerializeFloat32","title":"SerializeFloat32( block, offset, n, isLittleEndian )","titleHTML":"SerializeFloat32( block, offset, n, isLittleEndian )","number":"5.5.1","namespace":"<no location>","location":"","referencingIds":["_ref_326"],"key":"SerializeFloat32( block, offset, n, isLittleEndian )"},{"type":"op","aoid":"DeserializeFloat32","refId":"deserialize-float32","location":"","referencingIds":[],"key":"DeserializeFloat32"},{"type":"clause","id":"deserialize-float32","aoid":"DeserializeFloat32","title":"DeserializeFloat32( block, offset, isLittleEndian )","titleHTML":"DeserializeFloat32( block, offset, isLittleEndian )","number":"5.5.2","namespace":"<no location>","location":"","referencingIds":["_ref_327"],"key":"DeserializeFloat32( block, offset, isLittleEndian )"},{"type":"op","aoid":"SerializeInt","refId":"serialize-int","location":"","referencingIds":[],"key":"SerializeInt"},{"type":"clause","id":"serialize-int","aoid":"SerializeInt","title":"SerializeInt( descriptor )( block, offset, n, isLittleEndian )","titleHTML":"SerializeInt( descriptor )( block, offset, n, isLittleEndian )","number":"5.5.3","namespace":"<no location>","location":"","referencingIds":["_ref_330","_ref_334","_ref_338","_ref_342","_ref_346","_ref_350"],"key":"SerializeInt( descriptor )( block, offset, n, isLittleEndian )"},{"type":"op","aoid":"DeserializeInt","refId":"deserialize-int","location":"","referencingIds":[],"key":"DeserializeInt"},{"type":"clause","id":"deserialize-int","aoid":"DeserializeInt","title":"DeserializeInt( descriptor )( block, offset, isLittleEndian )","titleHTML":"DeserializeInt( descriptor )( block, offset, isLittleEndian )","number":"5.5.4","namespace":"<no location>","location":"","referencingIds":["_ref_331","_ref_335","_ref_339","_ref_343","_ref_347","_ref_351"],"key":"DeserializeInt( descriptor )( block, offset, isLittleEndian )"},{"type":"table","id":"simd-descriptor-table","number":3,"caption":"Table 3: SIMD type descriptors","referencingIds":[],"namespace":"<no location>","location":"","key":"Table 3: SIMD type descriptors"},{"type":"clause","id":"simd-descriptors","aoid":null,"title":"SIMD type descriptors","titleHTML":"SIMD type descriptors","number":"5.5","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD type descriptors"},{"type":"op","aoid":"%SIMD%","refId":"simd","location":"","referencingIds":[],"key":"%SIMD%"},{"type":"clause","id":"simd","aoid":"%SIMD%","title":"SIMD","titleHTML":"SIMD","number":"5","namespace":"<no location>","location":"","referencingIds":[],"key":"SIMD"}]</script><script>"use strict";

function Search(menu) {
  this.menu = menu;
  this.$search = document.getElementById('menu-search');
  this.$searchBox = document.getElementById('menu-search-box');
  this.$searchResults = document.getElementById('menu-search-results');
  
  this.loadBiblio();
  
  document.addEventListener('keydown', this.documentKeydown.bind(this));
  
  this.$searchBox.addEventListener('keydown', debounce(this.searchBoxKeydown.bind(this), { stopPropagation: true }));
  this.$searchBox.addEventListener('keyup', debounce(this.searchBoxKeyup.bind(this), { stopPropagation: true }));
}

Search.prototype.loadBiblio = function () {
  var $biblio = document.getElementById('menu-search-biblio');
  if (!$biblio) {
    this.biblio = [];
  } else {
    this.biblio = JSON.parse($biblio.textContent);
    this.biblio.clauses = this.biblio.filter(function (e) { return e.type === 'clause' });
    this.biblio.byId = this.biblio.reduce(function (map, entry) {
      map[entry.id] = entry;
      return map;
    }, {});
  }
}

Search.prototype.documentKeydown = function (e) {
  if (e.keyCode === 191) {
    e.preventDefault();
    e.stopPropagation();
    this.triggerSearch();
  }
}

Search.prototype.searchBoxKeydown = function (e) {
  e.stopPropagation();
  e.preventDefault();
  if (e.keyCode === 191 && e.target.value.length === 0) {
    e.preventDefault();
  } else if (e.keyCode === 13) {
    e.preventDefault();
    this.selectResult();
  }
}

Search.prototype.searchBoxKeyup = function (e) {
  if (e.keyCode === 13 || e.keyCode === 9) {
    return;
  }
  
  this.search(e.target.value);
}


Search.prototype.triggerSearch = function (e) {
  if (this.menu.isVisible()) {
    this._closeAfterSearch = false;
  } else {
    this._closeAfterSearch = true;
    this.menu.show();
  }

  this.$searchBox.focus();
  this.$searchBox.select();
}
// bit 12 - Set if the result starts with searchString
// bits 8-11: 8 - number of chunks multiplied by 2 if cases match, otherwise 1.
// bits 1-7: 127 - length of the entry
// General scheme: prefer case sensitive matches with fewer chunks, and otherwise
// prefer shorter matches.
function relevance(result, searchString) {
  var relevance = 0;
  
  relevance = Math.max(0, 8 - result.match.chunks) << 7;
  
  if (result.match.caseMatch) {
    relevance *= 2;
  }
  
  if (result.match.prefix) {
    relevance += 2048
  }
  
  relevance += Math.max(0, 255 - result.entry.key.length);
  
  return relevance;
}

Search.prototype.search = function (searchString) {
  var s = Date.now();

  if (searchString === '') {
    this.displayResults([]);
    this.hideSearch();
    return;
  } else {
    this.showSearch();
  }
  
  if (searchString.length === 1) {
    this.displayResults([]);
    return;
  }
    
  var results;

  if (/^[\d\.]*$/.test(searchString)) {
    results = this.biblio.clauses.filter(function (clause) {
      return clause.number.substring(0, searchString.length) === searchString;
    }).map(function (clause) {
      return { entry: clause };
    });
  } else {
    results = [];
    
    for (var i = 0; i < this.biblio.length; i++) {
      var entry = this.biblio[i];
  
      var match = fuzzysearch(searchString, entry.key);
      if (match) {
        results.push({ entry: entry, match: match });
      }
    }
  
    results.forEach(function (result) {
      result.relevance = relevance(result, searchString);
    });
    
    results = results.sort(function (a, b) { return b.relevance - a.relevance });

  }

  if (results.length > 50) {
    results = results.slice(0, 50);
  }
  
  this.displayResults(results);
}
Search.prototype.hideSearch = function () {
  this.$search.classList.remove('active');
}

Search.prototype.showSearch = function () {
  this.$search.classList.add('active');
}

Search.prototype.selectResult = function () {
  var $first = this.$searchResults.querySelector('li:first-child a');

  if ($first) {
    document.location = $first.getAttribute('href');
  }
  
  this.$searchBox.value = '';
  this.$searchBox.blur();
  this.displayResults([]);
  this.hideSearch();

  if (this._closeAfterSearch) {
    this.menu.hide();
  }
}

Search.prototype.displayResults = function (results) {
  if (results.length > 0) {
    this.$searchResults.classList.remove('no-results');
    
    var html = '<ul>';

    results.forEach(function (result) {
      var entry = result.entry;
      var id = entry.id;
      var cssClass = '';
      var text = '';

      if (entry.type === 'clause') {
        var number = entry.number ? entry.number + ' ' : '';
        text = number + entry.key;
        cssClass = 'clause';
        id = entry.id;
      } else if (entry.type === 'production') {
        text = entry.key;
        cssClass = 'prod';
        id = entry.id;  
      } else if (entry.type === 'op') {
        text = entry.key;
        cssClass = 'op';
        id = entry.id || entry.refId;
      } else if (entry.type === 'term') {
        text = entry.key;
        cssClass = 'term';
        id = entry.id || entry.refId;
      }

      if (text) {
        html += '<li class=menu-search-result-' + cssClass + '><a href="#' + id + '">' + text + '</a></li>'
      }
    });

    html += '</ul>'

    this.$searchResults.innerHTML = html;
  } else {
    this.$searchResults.innerHTML = '';
    this.$searchResults.classList.add('no-results');
  }
}


function Menu() {
  this.$toggle = document.getElementById('menu-toggle');
  this.$menu = document.getElementById('menu');
  this.$toc = document.querySelector('menu-toc > ol');
  this.$pins = document.querySelector('#menu-pins');
  this.$pinList = document.getElementById('menu-pins-list');
  this.$toc = document.querySelector('#menu-toc > ol');
  this.$specContainer = document.getElementById('spec-container');
  this.search = new Search(this);
  
  this._pinnedIds = {}; 
  this.loadPinEntries();

  // toggle menu
  this.$toggle.addEventListener('click', this.toggle.bind(this));

  // keydown events for pinned clauses
  document.addEventListener('keydown', this.documentKeydown.bind(this));

  // toc expansion
  var tocItems = this.$menu.querySelectorAll('#menu-toc li');
  for (var i = 0; i < tocItems.length; i++) {
    var $item = tocItems[i];
    $item.addEventListener('click', function($item, event) {
      $item.classList.toggle('active');
      event.stopPropagation();
    }.bind(null, $item));
  }

  // close toc on toc item selection
  var tocLinks = this.$menu.querySelectorAll('#menu-toc li > a');
  for (var i = 0; i < tocLinks.length; i++) {
    var $link = tocLinks[i];
    $link.addEventListener('click', function(event) {
      this.toggle();
      event.stopPropagation();
    }.bind(this));
  }

  // update active clause on scroll
  window.addEventListener('scroll', debounce(this.updateActiveClause.bind(this)));
  this.updateActiveClause();

  // prevent menu scrolling from scrolling the body
  this.$toc.addEventListener('wheel', function (e) {
    var target = e.currentTarget;
    var offTop = e.deltaY < 0 && target.scrollTop === 0;
    if (offTop) {
      e.preventDefault();
    }
    var offBottom = e.deltaY > 0
                    && target.offsetHeight + target.scrollTop >= target.scrollHeight;

    if (offBottom) {
		  e.preventDefault();
	  }
  })
}

Menu.prototype.documentKeydown = function (e) {
  e.stopPropagation();
  if (e.keyCode === 80) {
    this.togglePinEntry();
  } else if (e.keyCode > 48 && e.keyCode < 58) {
    this.selectPin(e.keyCode - 49);
  }
}

Menu.prototype.updateActiveClause = function () {
  this.setActiveClause(findActiveClause(this.$specContainer))
}

Menu.prototype.setActiveClause = function (clause) {
  this.$activeClause = clause;
  this.revealInToc(this.$activeClause);
}

Menu.prototype.revealInToc = function (path) {
  var current = this.$toc.querySelectorAll('li.revealed');
  for (var i = 0; i < current.length; i++) {
    current[i].classList.remove('revealed');
    current[i].classList.remove('revealed-leaf');
  }
  
  var current = this.$toc;
  var index = 0;
  while (index < path.length) {
    var children = current.children;
    for (var i = 0; i < children.length; i++) {
      if ('#' + path[index].id === children[i].children[1].getAttribute('href') ) {
        children[i].classList.add('revealed');
        if (index === path.length - 1) {
          children[i].classList.add('revealed-leaf');
          var rect = children[i].getBoundingClientRect();
          this.$toc.getBoundingClientRect().top
          var tocRect = this.$toc.getBoundingClientRect();
          if (rect.top + 10 > tocRect.bottom) {
            this.$toc.scrollTop = this.$toc.scrollTop + (rect.top - tocRect.bottom) + (rect.bottom - rect.top);
          } else if (rect.top < tocRect.top) {
            this.$toc.scrollTop = this.$toc.scrollTop - (tocRect.top - rect.top);
          }
        }
        current = children[i].querySelector('ol');
        index++;
        break;
      }      
    }
    
  }
}

function findActiveClause(root, path) {
  var clauses = new ClauseWalker(root);
  var $clause;
  var found = false;
  var path = path || [];
  
  while ($clause = clauses.nextNode()) {
    var rect = $clause.getBoundingClientRect();
    var $header = $clause.children[0];
    var marginTop = parseInt(getComputedStyle($header)["margin-top"]);
    
    if ((rect.top - marginTop) <= 0 && rect.bottom > 0) {
      found = true;
      return findActiveClause($clause, path.concat($clause)) || path;
    }
  }
  
  return path;
}

function ClauseWalker(root) {
  var previous;
  var treeWalker = document.createTreeWalker(
    root,
    NodeFilter.SHOW_ELEMENT,
    {
      acceptNode: function (node) {
        if (previous === node.parentNode) {
          return NodeFilter.FILTER_REJECT;
        } else {
          previous = node;
        }
        if (node.nodeName === 'EMU-CLAUSE' || node.nodeName === 'EMU-INTRO' || node.nodeName === 'EMU-ANNEX') {
          return NodeFilter.FILTER_ACCEPT;
        } else {
          return NodeFilter.FILTER_SKIP;
        }
      }
    },
    false
    );
  
  return treeWalker;
}

Menu.prototype.toggle = function () {
  this.$menu.classList.toggle('active');
}

Menu.prototype.show = function () {
  this.$menu.classList.add('active');
}

Menu.prototype.hide = function () {
  this.$menu.classList.remove('active');
}

Menu.prototype.isVisible = function() {
  return this.$menu.classList.contains('active');
}

Menu.prototype.showPins = function () {
  this.$pins.classList.add('active');
}

Menu.prototype.hidePins = function () {
  this.$pins.classList.remove('active');
}

Menu.prototype.addPinEntry = function (id) {
  var entry = this.search.biblio.byId[id];
  if (!entry) {
    // id was deleted after pin (or something) so remove it
    delete this._pinnedIds[id];
    this.persistPinEntries();
    return;
  }

  if (entry.type === 'clause') {
    var prefix;
    if (entry.number) {
      prefix = entry.number + ' ';
    } else {
      prefix = '';
    }
    this.$pinList.innerHTML += '<li><a href="#' + entry.id + '">' + prefix + entry.titleHTML + '</a></li>';
  } else {
    this.$pinList.innerHTML += '<li><a href="#' + entry.id + '">' + entry.key + '</a></li>';
  }

  if (Object.keys(this._pinnedIds).length === 0) {
    this.showPins();
  }
  this._pinnedIds[id] = true;
  this.persistPinEntries();
}

Menu.prototype.removePinEntry = function (id) {
  var item = this.$pinList.querySelector('a[href="#' + id + '"]').parentNode;
  this.$pinList.removeChild(item);
  delete this._pinnedIds[id];
  if (Object.keys(this._pinnedIds).length === 0) {
    this.hidePins();
  }

  this.persistPinEntries();
}

Menu.prototype.persistPinEntries = function () {
  try {
    if (!window.localStorage) return;
  } catch (e) {
    return;
  }

  localStorage.pinEntries = JSON.stringify(Object.keys(this._pinnedIds));
}

Menu.prototype.loadPinEntries = function () {
  try {
    if (!window.localStorage) return;
  } catch (e) {
    return;
  }
  
  var pinsString = window.localStorage.pinEntries;
  if (!pinsString) return;
  var pins = JSON.parse(pinsString);
  for(var i = 0; i < pins.length; i++) {
    this.addPinEntry(pins[i]);
  }
}

Menu.prototype.togglePinEntry = function (id) {
  if (!id) {
    id = this.$activeClause[this.$activeClause.length - 1].id;
  }

  if (this._pinnedIds[id]) {
    this.removePinEntry(id);
  } else {
    this.addPinEntry(id);
  }
}

Menu.prototype.selectPin = function (num) {
  document.location = this.$pinList.children[num].children[0].href;
}

var menu;
function init() {
  menu = new Menu();
  var $container = document.getElementById('spec-container');
  $container.addEventListener('mouseover', debounce(function (e) {
    Toolbox.activateIfMouseOver(e);
  }));
}

document.addEventListener('DOMContentLoaded', init);

function debounce(fn, opts) {
  opts = opts || {};
  var timeout;
  return function(e) {
    if (opts.stopPropagation) {
      e.stopPropagation();
    }
    var args = arguments;
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(function() {
      timeout = null;
      fn.apply(this, args);
    }.bind(this), 150);
  }
}

var CLAUSE_NODES = ['EMU-CLAUSE', 'EMU-INTRO', 'EMU-ANNEX'];
function findLocalReferences ($elem) {
  var name = $elem.innerHTML;
  var references = [];

  var parentClause = $elem.parentNode;
  while (parentClause && CLAUSE_NODES.indexOf(parentClause.nodeName) === -1) {
    parentClause = parentClause.parentNode;
  }

  if(!parentClause) return;

  var vars = parentClause.querySelectorAll('var');

  for (var i = 0; i < vars.length; i++) {
    var $var = vars[i];

    if ($var.innerHTML === name) {
      references.push($var);
    }
  }

  return references;
}

function toggleFindLocalReferences($elem) {
  var references = findLocalReferences($elem);
  if ($elem.classList.contains('referenced')) {
    references.forEach(function ($reference) {
      $reference.classList.remove('referenced');
    });
  } else {
    references.forEach(function ($reference) {
      $reference.classList.add('referenced');
    });
  }
}

function installFindLocalReferences () {
  document.addEventListener('click', function (e) {
    if (e.target.nodeName === 'VAR') {
      toggleFindLocalReferences(e.target);
    }
  });
}

document.addEventListener('DOMContentLoaded', installFindLocalReferences);




// The following license applies to the fuzzysearch function
// The MIT License (MIT)
// Copyright © 2015 Nicolas Bevacqua
// Copyright © 2016 Brian Terlson
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
function fuzzysearch (searchString, haystack, caseInsensitive) {
  var tlen = haystack.length;
  var qlen = searchString.length;
  var chunks = 1;
  var finding = false;
  var prefix = true;
  
  if (qlen > tlen) {
    return false;
  }
  
  if (qlen === tlen) {
    if (searchString === haystack) {
      return { caseMatch: true, chunks: 1, prefix: true };
    } else if (searchString.toLowerCase() === haystack.toLowerCase()) {
      return { caseMatch: false, chunks: 1, prefix: true };
    } else {
      return false;
    }
  }
  
  outer: for (var i = 0, j = 0; i < qlen; i++) {
    var nch = searchString[i];
    while (j < tlen) {
      var targetChar = haystack[j++];
      if (targetChar === nch) {
        finding = true;
        continue outer;
      }
      if (finding) {
        chunks++;
        finding = false;
      }
    }
    
    if (caseInsensitive) { return false }
    
    return fuzzysearch(searchString.toLowerCase(), haystack.toLowerCase(), true);
  }
  
  return { caseMatch: !caseInsensitive, chunks: chunks, prefix: j <= qlen };
}

var Toolbox = {
  init: function () {
    this.$container = document.createElement('div');
    this.$container.classList.add('toolbox');
    this.$permalink = document.createElement('a');
    this.$permalink.textContent = 'Permalink';
    this.$pinLink = document.createElement('a');
    this.$pinLink.textContent = 'Pin';
    this.$pinLink.setAttribute('href', '#');
    this.$pinLink.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();
      menu.togglePinEntry(this.entry.id);
    }.bind(this));

    this.$refsLink = document.createElement('a');
    this.$refsLink.setAttribute('href', '#');
    this.$refsLink.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();
      referencePane.showReferencesFor(this.entry);
    }.bind(this));
    this.$container.appendChild(this.$permalink);
    this.$container.appendChild(this.$pinLink);
    this.$container.appendChild(this.$refsLink);
    document.body.appendChild(this.$container);
  },

  activate: function (el, entry, target) {
    if (el === this._activeEl) return;
    this.active = true;
    this.entry = entry;
    this.$container.classList.add('active');
    this.top = el.offsetTop - this.$container.offsetHeight - 10;
    this.left = el.offsetLeft;
    this.$container.setAttribute('style', 'left: ' + this.left + 'px; top: ' + this.top + 'px');
    this.updatePermalink();
    this.updateReferences();
    this._activeEl = el;
    if (this.top < document.body.scrollTop && el === target) {
      // don't scroll unless it's a small thing (< 200px)
      this.$container.scrollIntoView();
    }
  },

  updatePermalink: function () {
    this.$permalink.setAttribute('href', '#' + this.entry.id);
  },

  updateReferences: function () {
    this.$refsLink.textContent = 'References (' + this.entry.referencingIds.length + ')';
  },

  activateIfMouseOver: function (e) {
    var ref = this.findReferenceUnder(e.target);
    if (ref && (!this.active || e.pageY > this._activeEl.offsetTop)) {
      var entry = menu.search.biblio.byId[ref.id];
      this.activate(ref.element, entry, e.target);
    } else if (this.active && ((e.pageY < this.top) || e.pageY > (this._activeEl.offsetTop + this._activeEl.offsetHeight))) {
      this.deactivate();
    }
  },

  findReferenceUnder: function (el) {
    while (el) {
      var parent = el.parentNode;
      if (el.nodeName === 'H1' && parent.nodeName.match(/EMU-CLAUSE|EMU-ANNEX|EMU-INTRO/) && parent.id) {
        return { element: el, id: parent.id };
      } else if (el.nodeName.match(/EMU-(?!CLAUSE|XREF|ANNEX|INTRO)|DFN/) &&
                el.id && el.id[0] !== '_') {
        if (el.nodeName === 'EMU-FIGURE' || el.nodeName === 'EMU-TABLE' || el.nodeName === 'EMU-EXAMPLE') {
          // return the figcaption element
          return { element: el.children[0].children[0], id: el.id };
        } else if (el.nodeName === 'EMU-PRODUCTION') {
          // return the LHS non-terminal element
          return { element: el.children[0], id: el.id };
        } else {
          return { element: el, id: el.id };
        }
      }
      el = parent;
    }
  },

  deactivate: function () {
    this.$container.classList.remove('active');
    this._activeEl = null;
    this.activeElBounds = null;
    this.active = false;
  }
}

var referencePane = {
  init: function() {
    this.$container = document.createElement('div');
    this.$container.setAttribute('id', 'references-pane-container');

    var $spacer = document.createElement('div');
    $spacer.setAttribute('id', 'references-pane-spacer');

    this.$pane = document.createElement('div');
    this.$pane.setAttribute('id', 'references-pane');

    this.$container.appendChild($spacer);
    this.$container.appendChild(this.$pane);

    this.$header = document.createElement('div');
    this.$header.classList.add('menu-pane-header');
    this.$header.textContent = 'References to ';
    this.$headerRefId = document.createElement('a');
    this.$header.appendChild(this.$headerRefId);
    this.$closeButton = document.createElement('span');
    this.$closeButton.setAttribute('id', 'references-pane-close');
    this.$closeButton.addEventListener('click', function (e) {
      this.deactivate();
    }.bind(this));
    this.$header.appendChild(this.$closeButton);

    this.$pane.appendChild(this.$header);
    var tableContainer = document.createElement('div');
    tableContainer.setAttribute('id', 'references-pane-table-container');

    this.$table = document.createElement('table');
    this.$table.setAttribute('id', 'references-pane-table');

    this.$tableBody = this.$table.createTBody();

    tableContainer.appendChild(this.$table);
    this.$pane.appendChild(tableContainer);

    menu.$specContainer.appendChild(this.$container);
  },

  activate: function () {
    this.$container.classList.add('active');
  },

  deactivate: function () {
    this.$container.classList.remove('active');
  },

  showReferencesFor(entry) {
    this.activate();
    var newBody = document.createElement('tbody');
    var previousId;
    var previousCell;
    var dupCount = 0;
    this.$headerRefId.textContent = '#' + entry.id;
    this.$headerRefId.setAttribute('href', '#' + entry.id);
    entry.referencingIds.map(function (id) {
      var target = document.getElementById(id);
      var cid = findParentClauseId(target);
      var clause = menu.search.biblio.byId[cid];
      var dupCount = 0;
      return { id: id, clause: clause }
    }).sort(function (a, b) {
      return sortByClauseNumber(a.clause, b.clause);
    }).forEach(function (record, i) {
      if (previousId === record.clause.id) {
        previousCell.innerHTML += ' (<a href="#' + record.id + '">' + (dupCount + 2) + '</a>)';
        dupCount++;
      } else {
        var row = newBody.insertRow();
        var cell = row.insertCell();
        cell.innerHTML = record.clause.number;
        cell = row.insertCell();
        cell.innerHTML = '<a href="#' + record.id + '">' + record.clause.titleHTML + '</a>';
        previousCell = cell;
        previousId = record.clause.id;
        dupCount = 0;
      }
    }, this);
    this.$table.removeChild(this.$tableBody);
    this.$tableBody = newBody;
    this.$table.appendChild(this.$tableBody);
  }
}
function findParentClauseId(node) {
  while (node && node.nodeName !== 'EMU-CLAUSE' && node.nodeName !== 'EMU-INTRO' && node.nodeName !== 'EMU-ANNEX') {
    node = node.parentNode;
  }
  if (!node) return null;
  return node.getAttribute('id');
}

function sortByClauseNumber(c1, c2) {
  var c1c = c1.number.split('.');
  var c2c = c2.number.split('.');

  for (var i = 0; i < c1c.length; i++) {
    if (i >= c2c.length) {
      return 1;
    }
    
    var c1 = c1c[i];
    var c2 = c2c[i];
    var c1cn = Number(c1);
    var c2cn = Number(c2);

    if (Number.isNaN(c1cn) && Number.isNaN(c2cn)) {
      if (c1 > c2) {
        return 1;
      } else if (c1 < c2) {
        return -1;
      }
    } else if (!Number.isNaN(c1cn) && Number.isNaN(c2cn)) {
      return -1;
    } else if (Number.isNaN(c1cn) && !Number.isNaN(c2cn)) {
      return 1;
    } else if(c1cn > c2cn) {
      return 1;
    } else if (c1cn < c2cn) {
      return -1;
    }
  }

  if (c1c.length === c2c.length) {
    return 0;
  }
  return -1;
}

document.addEventListener('DOMContentLoaded', function () {
  Toolbox.init();
  referencePane.init();
})
var CLAUSE_NODES = ['EMU-CLAUSE', 'EMU-INTRO', 'EMU-ANNEX'];
function findLocalReferences ($elem) {
  var name = $elem.innerHTML;
  var references = [];

  var parentClause = $elem.parentNode;
  while (parentClause && CLAUSE_NODES.indexOf(parentClause.nodeName) === -1) {
    parentClause = parentClause.parentNode;
  }

  if(!parentClause) return;

  var vars = parentClause.querySelectorAll('var');

  for (var i = 0; i < vars.length; i++) {
    var $var = vars[i];

    if ($var.innerHTML === name) {
      references.push($var);
    }
  }

  return references;
}

function toggleFindLocalReferences($elem) {
  var references = findLocalReferences($elem);
  if ($elem.classList.contains('referenced')) {
    references.forEach(function ($reference) {
      $reference.classList.remove('referenced');
    });
  } else {
    references.forEach(function ($reference) {
      $reference.classList.add('referenced');
    });
  }
}

function installFindLocalReferences () {
  document.addEventListener('click', function (e) {
    if (e.target.nodeName === 'VAR') {
      toggleFindLocalReferences(e.target);
    }
  });
}

document.addEventListener('DOMContentLoaded', installFindLocalReferences);
</script><style>body {
  display: flex;
  font-size: 18px;
  line-height: 1.5;
  font-family: Cambria, Palatino Linotype, Palatino, Liberation Serif, serif;
  padding: 0;
  margin: 0;
  color: #111;
}

#spec-container {
  padding: 0 20px;
  flex-grow: 1;
  flex-basis: 66%;
  box-sizing: border-box;
  overflow: hidden;
}

body.oldtoc {
  margin: 0 auto;
}

a {
    text-decoration: none;
    color: #206ca7;
}

a:visited {
  color: #206ca7;
}

a:hover {
    text-decoration: underline;
    color: #239dee;
}


code {
    font-weight: bold;
    font-family: Consolas, Monaco, monospace;
    white-space: pre;
}

pre code {
  font-weight: inherit;
}

pre code.hljs {
  background-color: #fff;
  margin: 0;
  padding: 0;
}

ol.toc {
    list-style: none;
    padding-left: 0;
}

ol.toc ol.toc {
    padding-left: 2ex;
    list-style: none;
}

var {
  color: #2aa198;
  transition: background-color 0.25s ease;
  cursor: pointer;
}

var.referenced {
  background-color: #ffff33;
}

emu-const {
  font-family: sans-serif;
}

emu-val {
  font-weight: bold;
}
emu-alg ol, emu-alg ol ol ol ol {
    list-style-type: decimal;
}

emu-alg ol ol, emu-alg ol ol ol ol ol {
    list-style-type: lower-alpha;
}

emu-alg ol ol ol, ol ol ol ol ol ol {
    list-style-type: lower-roman;
}

emu-eqn {
  display: block;
  margin-left: 4em;
}

emu-eqn.inline {
  display: inline;
  margin: 0;
}

emu-eqn div:first-child {
  margin-left: -2em;
}

emu-note {
    margin: 1em 0;
    color: #666;
    border-left: 5px solid #ccc;
    display: flex;
    flex-direction: row;
}

emu-note > span.note {
    flex-basis: 100px;
    min-width: 100px;
    flex-grow: 0;
    flex-shrink: 1;
    text-transform: uppercase;
    padding-left: 5px;
}

emu-note[type=editor] {
  border-left-color: #faa;
}

emu-note > div.note-contents {
  flex-grow: 1;
  flex-shrink: 1;
}

emu-note > div.note-contents > p:first-child {
  margin-top: 0;
}

emu-note > div.note-contents > p:last-child {
  margin-bottom: 0;
}

emu-figure {
  display: block;
}

emu-example {
  display: block;
  margin: 1em 3em;
}

emu-example figure figcaption {
  margin-top: 0.5em;
  text-align: left;
}

emu-figure figure,
emu-example figure,
emu-table figure {
  display: flex;
  flex-direction: column;
  align-items: center;
}

emu-production {
    display: block;
    margin-top: 1em;
    margin-bottom: 1em;
    margin-left: 5ex;
}


emu-grammar.inline, emu-production.inline,
emu-grammar.inline emu-production emu-rhs, emu-production.inline emu-rhs {
  display: inline;
}

emu-grammar[collapsed] emu-production, emu-production[collapsed] {
    margin: 0;
}

emu-grammar[collapsed] emu-production emu-rhs, emu-production[collapsed] emu-rhs {
    display: inline;
    padding-left: 1ex;
}

emu-constraints {
    font-size: .75em;
    margin-right: 1ex;
}

emu-gann {
    margin-right: 1ex;
}

emu-gann emu-t:last-child,
emu-gann emu-nt:last-child {
    margin-right: 0;
}

emu-geq {
    margin-left: 1ex;
    font-weight: bold;
}

emu-oneof {
    font-weight: bold;
    margin-left: 1ex;
}

emu-nt {
    display: inline-block;
    font-style: italic;
    white-space: nowrap;
    text-indent: 0;
}

emu-nt a, emu-nt a:visited {
  color: #333;
}

emu-rhs emu-nt {
    margin-right: 1ex;
}

emu-t {
    display: inline-block;
    font-family: monospace;
    font-weight: bold;
    white-space: nowrap;
    text-indent: 0;
}

emu-production emu-t {
    margin-right: 1ex;
}

emu-rhs {
    display: block;
    padding-left: 75px;
    text-indent: -25px;
}

emu-mods {
    font-size: .85em;
    vertical-align: sub;
    font-style: normal;
    font-weight: normal;
}

emu-production[collapsed] emu-mods {
  display: none;
}

emu-params, emu-opt {
  margin-right: 1ex;
  font-family: monospace;
}

emu-params, emu-constraints {
  color: #2aa198;
}

emu-opt {
  color: #b58900;
}

emu-gprose {
    font-size: 0.9em;
    font-family: Helvetica, Arial, sans-serif;
}

h1.shortname {
  color: #f60;
  font-size: 1.5em;
  margin: 0;
}

h1.version {
  color: #f60;
  font-size: 1.5em;
  margin: 0;
}

h1.title {
  margin-top: 0;
  color: #f60;
}

h1.first {
  margin-top: 0;
}

h1, h2, h3, h4, h5, h6 {
    position: relative;
}

h1 .secnum {
  text-decoration: none;
  margin-right: 10px;
}

h1 span.title {
  order: 2;
}


h1 { font-size: 2.67em; margin-top: 2em; margin-bottom: 0; line-height: 1em;}
h2 { font-size: 2em; }
h3 { font-size: 1.56em; }
h4 { font-size: 1.25em; }
h5 { font-size: 1.11em; }
h6 { font-size: 1em; }

h1:hover span.utils {
  display: block;
}

span.utils {
  font-size: 18px;
  line-height: 18px;
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  font-weight: normal;
}

span.utils:before {
    content: "⤷";
    display: inline-block;
    padding: 0 5px;
}

span.utils > * {
  display: inline-block;
  margin-right: 20px;
}

h1 span.utils span.anchor a,
h2 span.utils span.anchor a,
h3 span.utils span.anchor a,
h4 span.utils span.anchor a,
h5 span.utils span.anchor a,
h6 span.utils span.anchor a {
  text-decoration: none;
  font-variant: small-caps;
}

h1 span.utils span.anchor a:hover,
h2 span.utils span.anchor a:hover,
h3 span.utils span.anchor a:hover,
h4 span.utils span.anchor a:hover,
h5 span.utils span.anchor a:hover,
h6 span.utils span.anchor a:hover {
  color: #333;
}

emu-intro h1, emu-clause h1, emu-annex h1 { font-size: 2em; }
emu-intro h2, emu-clause h2, emu-annex h2 { font-size: 1.56em; }
emu-intro h3, emu-clause h3, emu-annex h3 { font-size: 1.25em; }
emu-intro h4, emu-clause h4, emu-annex h4 { font-size: 1.11em; }
emu-intro h5, emu-clause h5, emu-annex h5 { font-size: 1em; }
emu-intro h6, emu-clause h6, emu-annex h6 { font-size: 0.9em; }
emu-intro emu-intro h1, emu-clause emu-clause h1, emu-annex emu-annex h1 { font-size: 1.56em; }
emu-intro emu-intro h2, emu-clause emu-clause h2, emu-annex emu-annex h2 { font-size: 1.25em; }
emu-intro emu-intro h3, emu-clause emu-clause h3, emu-annex emu-annex h3 { font-size: 1.11em; }
emu-intro emu-intro h4, emu-clause emu-clause h4, emu-annex emu-annex h4 { font-size: 1em; }
emu-intro emu-intro h5, emu-clause emu-clause h5, emu-annex emu-annex h5 { font-size: 0.9em; }
emu-intro emu-intro emu-intro h1, emu-clause emu-clause emu-clause h1, emu-annex emu-annex emu-annex h1 { font-size: 1.25em; }
emu-intro emu-intro emu-intro h2, emu-clause emu-clause emu-clause h2, emu-annex emu-annex emu-annex h2 { font-size: 1.11em; }
emu-intro emu-intro emu-intro h3, emu-clause emu-clause emu-clause h3, emu-annex emu-annex emu-annex h3 { font-size: 1em; }
emu-intro emu-intro emu-intro h4, emu-clause emu-clause emu-clause h4, emu-annex emu-annex emu-annex h4 { font-size: 0.9em; }
emu-intro emu-intro emu-intro emu-intro h1, emu-clause emu-clause emu-clause emu-clause h1, emu-annex emu-annex emu-annex emu-annex h1 { font-size: 1.11em; }
emu-intro emu-intro emu-intro emu-intro h2, emu-clause emu-clause emu-clause emu-clause h2, emu-annex emu-annex emu-annex emu-annex h2 { font-size: 1em; }
emu-intro emu-intro emu-intro emu-intro h3, emu-clause emu-clause emu-clause emu-clause h3, emu-annex emu-annex emu-annex emu-annex h3 { font-size: 0.9em; }
emu-intro emu-intro emu-intro emu-intro emu-intro h1, emu-clause emu-clause emu-clause emu-clause emu-clause h1, emu-annex emu-annex emu-annex emu-annex emu-annex h1 { font-size: 1em; }
emu-intro emu-intro emu-intro emu-intro emu-intro h2, emu-clause emu-clause emu-clause emu-clause emu-clause h2, emu-annex emu-annex emu-annex emu-annex emu-annex h2 { font-size: 0.9em; }
emu-intro emu-intro emu-intro emu-intro emu-intro emu-intro h1, emu-clause emu-clause emu-clause emu-clause emu-clause emu-clause h1, emu-annex emu-annex emu-annex emu-annex emu-annex emu-annex h1 { font-size: 0.9em }

emu-clause, emu-intro, emu-annex {
    display: block;
}

/* Figures and tables */
figure { display: block; margin: 1em 0 3em 0; }
figure object { display: block; margin: 0 auto; }
figure table.real-table { margin: 0 auto; }
figure figcaption {
    display: block;
    color: #555555;
    font-weight: bold;
    text-align: center;
}

emu-table table {
  margin: 0 auto;
}

emu-table table, table.real-table {
    border-collapse: collapse;
}

emu-table td, emu-table th, table.real-table td, table.real-table th {
    border: 1px solid black;
    padding: 0.4em;
    vertical-align: baseline;
}
emu-table th, emu-table thead td, table.real-table th {
    background-color: #eeeeee;
}

/* Note: the left content edges of table.lightweight-table >tbody >tr >td
   and div.display line up. */
table.lightweight-table {
    border-collapse: collapse;
    margin: 0 0 0 1.5em;
}
table.lightweight-table td, table.lightweight-table th {
    border: none;
    padding: 0 0.5em;
    vertical-align: baseline;
}

/* diff styles */
ins {
    background-color: #e0f8e0;
    text-decoration: none;
    border-bottom: 1px solid #396;
}

del {
    background-color: #fee;
}

ins.block, del.block,
emu-production > ins, emu-production > del,
emu-grammar > ins, emu-grammar > del {
  display: block;
}

/* Menu Styles */
#menu-toggle {
  font-size: 2em;

  position: fixed;
  top: 0;
  left: 0;
  width: 1.5em;
  height: 1.5em;
  z-index: 3;
  visibility: hidden;
  color: #1567a2;
  background-color: #fff;

  line-height: 1.5em;
  text-align: center;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;;

  cursor: pointer;
}

#menu {
  display: flex;
  flex-direction: column;
  width: 33%; height: 100vh;
  max-width: 500px;
  box-sizing: border-box;
  background-color: #ddd;
  overflow: hidden;
  transition: opacity 0.1s linear;
  padding: 0 5px;
  position: fixed;
  left: 0; top: 0;
  border-right: 2px solid #bbb;

  z-index: 2;
}

#menu-spacer {
  flex-basis: 33%;
  max-width: 500px;
  flex-grow: 0;
  flex-shrink: 0;
}

#menu a {
  color: #1567a2;
}

#menu.active {
  display: flex;
  opacity: 1;
  z-index: 2;
}

#menu-pins {
  flex-grow: 1;
  display: none;
}

#menu-pins.active {
  display: block;
}

#menu-pins-list {
  margin: 0;
  padding: 0;
  counter-reset: pins-counter;
}

#menu-pins-list > li:before {
  content: counter(pins-counter);
  counter-increment: pins-counter;
  display: inline-block;
  width: 25px;
  text-align: center;
  border: 1px solid #bbb;
  padding: 2px;
  margin: 4px;
  box-sizing: border-box;
  line-height: 1em;
  background-color: #ccc;
  border-radius: 4px;
}
#menu-toc > ol {
  padding: 0;
  flex-grow: 1;
}

#menu-toc > ol li {
  padding: 0;
}

#menu-toc > ol , #menu-toc > ol ol {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

#menu-toc > ol ol {
  padding-left: 0.75em;
}

#menu-toc li {
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
}

#menu-toc .item-toggle {
  display: inline-block;
  transform: rotate(-45deg) translate(-5px, -5px);
  transition: transform 0.1s ease;
  text-align: center;
  width: 20px;

  color: #aab;

  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;;

  cursor: pointer;
}

#menu-toc .item-toggle-none {
  display: inline-block;
  width: 20px;
}

#menu-toc li.active > .item-toggle {
  transform: rotate(45deg) translate(-5px, -5px);
}

#menu-toc li > ol {
  display: none;
}

#menu-toc li.active > ol {
  display: block;
}

#menu-toc li.revealed > a {
  background-color: #bbb;
  font-weight: bold;
  /*
  background-color: #222;
  color: #c6d8e4;
  */
}

#menu-toc li.revealed-leaf> a {
  color: #206ca7;
  /*
  background-color: #222;
  color: #c6d8e4;
  */
}

#menu-toc li.revealed > .item-toggle {
  transform: rotate(45deg) translate(-5px, -5px);
}

#menu-toc li.revealed > ol {
  display: block;
}

#menu-toc li > a {
  padding: 2px 5px;
}

#menu > * {
  margin-bottom: 5px;
}

.menu-pane-header {
  padding: 0 5px;
  text-transform: uppercase;
  background-color: #aaa;
  color: #335;
  font-weight: bold;
  letter-spacing: 2px;
  flex-grow: 0;
  flex-shrink: 0;
  font-size: 0.8em;
}

#menu-toc {
  display: flex;
  flex-direction: column;
  width: 100%;
  overflow: hidden;
  flex-grow: 1;
}

#menu-toc ol.toc {
  overflow-x: hidden;
  overflow-y: auto;
}

#menu-search {
  position: relative;
  flex-grow: 0;
  flex-shrink: 0;
  width: 100%;
  
  display: flex;
  flex-direction: column;
  
  max-height: 300px;
}

#menu-trace-list {
  display: none;
}

#menu-search-box {
  box-sizing: border-box;
  display: block;
  width: 100%;
  margin: 5px 0 0 0;
  font-size: 1em;
  padding: 2px;
  background-color: #bbb;
  border: 1px solid #999;
}

#menu-search-results {
  overflow-x: hidden;
  overflow-y: auto;
}

li.menu-search-result-clause:before {
    content: 'clause';
    width: 40px;
    display: inline-block;
    text-align: right;
    padding-right: 1ex;
    color: #666;
    font-size: 75%;
}
li.menu-search-result-op:before {
    content: 'op';
    width: 40px;
    display: inline-block;
    text-align: right;
    padding-right: 1ex;
    color: #666;
    font-size: 75%;
}

li.menu-search-result-prod:before {
    content: 'prod';
    width: 40px;
    display: inline-block;
    text-align: right;
    padding-right: 1ex;
    color: #666;
    font-size: 75%
}


li.menu-search-result-term:before {
    content: 'term';
    width: 40px;
    display: inline-block;
    text-align: right;
    padding-right: 1ex;
    color: #666;
    font-size: 75%
}

#menu-search-results ul {
  padding: 0 5px;
  margin: 0;
}

#menu-search-results li {
  white-space: nowrap;
  text-overflow: ellipsis;
}


#menu-trace-list {
  counter-reset: item;
  margin: 0 0 0 20px;
  padding: 0;
}
#menu-trace-list li {
  display: block;
  white-space: nowrap;
}

#menu-trace-list li .secnum:after {
  content: " ";
}
#menu-trace-list li:before {
    content: counter(item) " ";
    background-color: #222;
    counter-increment: item;
    color: #999;
    width: 20px;
    height: 20px;
    line-height: 20px;
    display: inline-block;
    text-align: center;
    margin: 2px 4px 2px 0;
}

@media (max-width: 1000px) {
  body {
    margin: 0;
    display: block;
  }

  #menu {
    display: none;
    padding-top: 3em;
    width: 450px;
  }

  #menu.active {
    position: fixed;
    height: 100%;
    left: 0;
    top: 0;
    right: 300px;
  }

  #menu-toggle {
    visibility: visible;
  }

  #spec-container {
    padding: 0 5px;
  }

  #references-pane-spacer {
    display: none;
  }
}

@media only screen and (max-width: 800px) {
  #menu {
    width: 100%;
  }

  h1 .secnum:empty {
    margin: 0; padding: 0;
  }
}


/* Toolbox */
.toolbox {
	position: absolute;
	background: #ddd;
	border: 1px solid #aaa;
  display: none;
  color: #eee;
  padding: 5px;
  border-radius: 3px;
}

.toolbox.active {
  display: inline-block;
}

.toolbox a {
  text-decoration: none;
  padding: 0 5px;
}

.toolbox a:hover {
  text-decoration: underline;
}

.toolbox:after, .toolbox:before {
	top: 100%;
	left: 15px;
	border: solid transparent;
	content: " ";
	height: 0;
	width: 0;
	position: absolute;
	pointer-events: none;
}

.toolbox:after {
	border-color: rgba(0, 0, 0, 0);
	border-top-color: #ddd;
	border-width: 10px;
	margin-left: -10px;
}
.toolbox:before {
	border-color: rgba(204, 204, 204, 0);
	border-top-color: #aaa;
	border-width: 12px;
	margin-left: -12px;
}

#references-pane-container {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 250px;
  display: none;
  background-color: #ddd;
  z-index: 1;
}

#references-pane-table-container {
  overflow-x: hidden;
  overflow-y: auto;
}

#references-pane-spacer {
  flex-basis: 33%;
  max-width: 500px;
}

#references-pane {
  flex-grow: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#references-pane-container.active {
  display: flex;
}

#references-pane-close:after {
  content: '✖';
  float: right;
  cursor: pointer;
}

#references-pane table tr td:first-child {
  text-align: right;
  padding-right: 5px;
}
</style></head><body><div id="menu-toggle">☰</div><div id="menu-spacer"></div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-pins"><div class="menu-pane-header">Pins</div><ul id="menu-pins-list"></ul></div><div class="menu-pane-header">Table of Contents</div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Introduction">Introduction</a></li><li><span class="item-toggle">◢</span><a href="#terms-and-defs" title="Terms and definitions (4.3)"><span class="secnum">1</span> Terms and definitions (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values">4.3</a>)<ol class="toc"><li><span class="item-toggle-none"></span><a href="#primitive-def" title="primitive value (4.3.2)"><span class="secnum">1.1</span> primitive value (</a><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-primitive-value">4.3.2</a>)</li><li><span class="item-toggle-none"></span><a href="#simd-meta-var-def" title="SIMD"><span class="secnum">1.2</span> <var>SIMD</var></a></li><li><span class="item-toggle-none"></span><a href="#simd-meta-var-def" title="SIMDDescriptor"><span class="secnum">1.3</span> <var>SIMD</var>Descriptor</a></li><li><span class="item-toggle-none"></span><a href="#simd-type-def" title="SIMD types"><span class="secnum">1.4</span> SIMD types</a></li><li><span class="item-toggle-none"></span><a href="#simd-value-def" title="SIMD value"><span class="secnum">1.5</span> SIMD value</a></li><li><span class="item-toggle-none"></span><a href="#simd-object-def" title="SIMD object"><span class="secnum">1.6</span> SIMD object</a></li><li><span class="item-toggle-none"></span><a href="#simd-type-descriptor-def" title="SIMD type descriptor"><span class="secnum">1.7</span> SIMD type descriptor</a></li><li><span class="item-toggle-none"></span><a href="#simd-boolean-type" title="SIMD boolean type"><span class="secnum">1.8</span> SIMD boolean type</a></li><li><span class="item-toggle-none"></span><a href="#simd-integer-type" title="SIMD integer type"><span class="secnum">1.9</span> SIMD integer type</a></li><li><span class="item-toggle-none"></span><a href="#simd-floating-point-type" title="SIMD floating-point type"><span class="secnum">1.10</span> SIMD floating-point type</a></li><li><span class="item-toggle-none"></span><a href="#simd-signed-integer-type" title="SIMD signed integer type"><span class="secnum">1.11</span> SIMD signed integer type</a></li><li><span class="item-toggle-none"></span><a href="#simd-unsigned-integer-type" title="SIMD unsigned integer type"><span class="secnum">1.12</span> SIMD unsigned integer type</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#types" title="ECMAScript Data Types and Values (6)"><span class="secnum">2</span> ECMAScript Data Types and Values (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values">6</a>)<ol class="toc"><li><span class="item-toggle">◢</span><a href="#all-types" title="ECMAScript language types (6.1)"><span class="secnum">2.1</span> ECMAScript language types (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types">6.1</a>)<ol class="toc"><li><span class="item-toggle">◢</span><a href="#object-type" title="The Object Type (6.1.7)"><span class="secnum">2.1.1</span> The Object Type (</a><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object-type">6.1.7</a>)<ol class="toc"><li><span class="item-toggle-none"></span><a href="#intrinsics" title="Well-Known Intrinsic Objects (6.1.7.4)"><span class="secnum">2.1.1.1</span> Well-Known Intrinsic Objects (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-well-known-intrinsic-objects">6.1.7.4</a>)</li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#simd-types" title="SIMD types"><span class="secnum">2.2</span> SIMD types</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#float32x4" title="Float32x4"><span class="secnum">2.2.1</span> Float32x4</a></li><li><span class="item-toggle-none"></span><a href="#int32x4" title="Int32x4"><span class="secnum">2.2.2</span> Int32x4</a></li><li><span class="item-toggle-none"></span><a href="#int16x8" title="Int16x8"><span class="secnum">2.2.3</span> Int16x8</a></li><li><span class="item-toggle-none"></span><a href="#int8x16" title="Int8x16"><span class="secnum">2.2.4</span> Int8x16</a></li><li><span class="item-toggle-none"></span><a href="#uint32x4" title="Uint32x4"><span class="secnum">2.2.5</span> Uint32x4</a></li><li><span class="item-toggle-none"></span><a href="#uint16x8" title="Uint16x8"><span class="secnum">2.2.6</span> Uint16x8</a></li><li><span class="item-toggle-none"></span><a href="#uint8x16" title="Uint8x16"><span class="secnum">2.2.7</span> Uint8x16</a></li><li><span class="item-toggle-none"></span><a href="#bool32x4" title="Bool32x4"><span class="secnum">2.2.8</span> Bool32x4</a></li><li><span class="item-toggle-none"></span><a href="#bool16x8" title="Bool16x8"><span class="secnum">2.2.9</span> Bool16x8</a></li><li><span class="item-toggle-none"></span><a href="#bool8x16" title="Bool8x16"><span class="secnum">2.2.10</span> Bool8x16</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#abstract-operations" title="Abstract Operations (7)"><span class="secnum">3</span> Abstract Operations (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-operations">7</a>)<ol class="toc"><li><span class="item-toggle">◢</span><a href="#type-conversion" title="Type Conversion (7.1)"><span class="secnum">3.1</span> Type Conversion (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-type-conversion">7.1</a>)<ol class="toc"><li><span class="item-toggle-none"></span><a href="#to-primitive" title="ToPrimitive ( input [, PreferredType] ) (7.1.1)"><span class="secnum">3.1.1</span> ToPrimitive ( input [, PreferredType] ) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive">7.1.1</a>)</li><li><span class="item-toggle-none"></span><a href="#to-boolean" title="ToBoolean ( argument ) (7.1.2)"><span class="secnum">3.1.2</span> ToBoolean ( argument ) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toboolean">7.1.2</a>)</li><li><span class="item-toggle-none"></span><a href="#to-number" title="ToNumber ( argument ) (7.1.3)"><span class="secnum">3.1.3</span> ToNumber ( argument ) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber">7.1.3</a>)</li><li><span class="item-toggle-none"></span><a href="#to-string" title="ToString ( argument ) (7.1.12)"><span class="secnum">3.1.4</span> ToString ( argument ) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-tostring">7.1.12</a>)</li><li><span class="item-toggle-none"></span><a href="#to-object" title="ToObject ( argument ) (7.1.13)"><span class="secnum">3.1.5</span> ToObject ( argument ) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toobject">7.1.13</a>)</li></ol></li><li><span class="item-toggle-none"></span><a href="#require-object-coercible" title="RequireObjectCoercible ( argument ) (7.2.1)"><span class="secnum">3.2</span> RequireObjectCoercible ( argument ) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-requireobjectcoercible">7.2.1</a>)</li><li><span class="item-toggle-none"></span><a href="#same-value" title="SameValue(x, y) (7.2.9)"><span class="secnum">3.3</span> SameValue(x, y) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-samevalue">7.2.9</a>)</li><li><span class="item-toggle-none"></span><a href="#same-value-zero" title="SameValueZero(x, y) (7.2.10)"><span class="secnum">3.4</span> SameValueZero(x, y) (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero">7.2.10</a>)</li><li><span class="item-toggle-none"></span><a href="#abstract-equality" title="Abstract Equality Comparison (7.2.12)"><span class="secnum">3.5</span> Abstract Equality Comparison (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison">7.2.12</a>)</li><li><span class="item-toggle-none"></span><a href="#strict-equality-comparison" title="Strict Equality Comparison (7.2.13)"><span class="secnum">3.6</span> Strict Equality Comparison (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison">7.2.13</a>)</li></ol></li><li><span class="item-toggle">◢</span><a href="#typeof" title="The typeof Operator (12.5.6)"><span class="secnum">4</span> The typeof Operator (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator">12.5.6</a>)<ol class="toc"><li><span class="item-toggle-none"></span><a href="#typeof-evaluation" title="Runtime Semantics: Evaluation (12.5.6.1)"><span class="secnum">4.1</span> RS: Evaluation (</a><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation">12.5.6.1</a>)</li></ol></li><li><span class="item-toggle">◢</span><a href="#simd" title="SIMD"><span class="secnum">5</span> SIMD</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#simd-algorithms" title="Internal algorithms on SIMD types"><span class="secnum">5.1</span> Internal algorithms on SIMD types</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#simd-create" title="SIMDCreate( descriptor, vectorElements )"><span class="secnum">5.1.1</span> SIMDCreate( descriptor, vectorElements )</a></li><li><span class="item-toggle-none"></span><a href="#simd-to-lane" title="SIMDToLane( max, lane )"><span class="secnum">5.1.2</span> SIMDToLane( max, lane )</a></li><li><span class="item-toggle-none"></span><a href="#simd-abstract-extract-lane" title="SIMDExtractLane( value, lane )"><span class="secnum">5.1.3</span> SIMDExtractLane( value, lane )</a></li><li><span class="item-toggle-none"></span><a href="#simd-abstract-replace-lane" title="SIMDReplaceLane( value, lane, replacement )"><span class="secnum">5.1.4</span> SIMDReplaceLane( value, lane, replacement )</a></li><li><span class="item-toggle-none"></span><a href="#maybe-flush-denormal" title="MaybeFlushDenormal( n, descriptor )"><span class="secnum">5.1.5</span> MaybeFlushDenormal( n, descriptor )</a></li><li><span class="item-toggle-none"></span><a href="#simd-binary" title="SIMDBinaryOp( a, b, op, outputDescriptor )"><span class="secnum">5.1.6</span> SIMDBinaryOp( a, b, op, outputDescriptor )</a></li><li><span class="item-toggle-none"></span><a href="#simd-unary" title="SIMDUnaryOp( a, op [ , flushDenormal ] )"><span class="secnum">5.1.7</span> SIMDUnaryOp( a, op [ , flushDenormal ] )</a></li><li><span class="item-toggle-none"></span><a href="#simd-scalar" title="SIMDScalarOp( a, scalar, op )"><span class="secnum">5.1.8</span> SIMDScalarOp( a, scalar, op )</a></li><li><span class="item-toggle-none"></span><a href="#simd-load" title="SIMDLoad( dataBlock, descriptor, byteOffset [, length] )"><span class="secnum">5.1.9</span> SIMDLoad( dataBlock, descriptor, byteOffset [, length] )</a></li><li><span class="item-toggle-none"></span><a href="#simd-load-from-tarray" title="SIMDLoadFromTypedArray( tarray, index, descriptor [, length] )"><span class="secnum">5.1.10</span> SIMDLoadFromTypedArray( tarray, index, descriptor [, length] )</a></li><li><span class="item-toggle-none"></span><a href="#simd-store" title="SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )"><span class="secnum">5.1.11</span> SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )</a></li><li><span class="item-toggle-none"></span><a href="#simd-store-in-tarray" title="SIMDStoreInTypedArray( tarray, index, descriptor, n [, length] )"><span class="secnum">5.1.12</span> SIMDStoreInTypedArray( tarray, index, descriptor, n [, length] )</a></li><li><span class="item-toggle-none"></span><a href="#simd-reinterpret-cast" title="SIMDReinterpretCast( value, newDescriptor )"><span class="secnum">5.1.13</span> SIMDReinterpretCast( value, newDescriptor )</a></li><li><span class="item-toggle-none"></span><a href="#simd-int-type" title="SIMDBoolType( descriptor )"><span class="secnum">5.1.14</span> SIMDBoolType( descriptor )</a></li><li><span class="item-toggle-none"></span><a href="#simd-relational-op" title="SIMDRelationalOp( a, b, op )"><span class="secnum">5.1.15</span> SIMDRelationalOp( a, b, op )</a></li><li><span class="item-toggle-none"></span><a href="#abs" title="MathAbs( x )"><span class="secnum">5.1.16</span> MathAbs( x )</a></li><li><span class="item-toggle-none"></span><a href="#fround" title="ToFloat32( argument )"><span class="secnum">5.1.17</span> ToFloat32( argument )</a></li><li><span class="item-toggle-none"></span><a href="#abs" title="MathSqrt( x )"><span class="secnum">5.1.18</span> MathSqrt( x )</a></li><li><span class="item-toggle-none"></span><a href="#imul" title="MathImul(n, m)"><span class="secnum">5.1.19</span> MathImul(n, m)</a></li><li><span class="item-toggle-none"></span><a href="#min" title="MathMin(n, m)"><span class="secnum">5.1.20</span> MathMin(n, m)</a></li><li><span class="item-toggle-none"></span><a href="#max-num" title="MaxNum(n, m)"><span class="secnum">5.1.21</span> MaxNum(n, m)</a></li><li><span class="item-toggle-none"></span><a href="#min-num" title="MinNum(n, m)"><span class="secnum">5.1.22</span> MinNum(n, m)</a></li><li><span class="item-toggle-none"></span><a href="#reciprocal" title="ReciprocalApproximation(n)"><span class="secnum">5.1.23</span> ReciprocalApproximation(n)</a></li><li><span class="item-toggle-none"></span><a href="#reciprocal" title="ReciprocalSqrtApproximation(n)"><span class="secnum">5.1.24</span> ReciprocalSqrtApproximation(n)</a></li><li><span class="item-toggle-none"></span><a href="#saturate" title="Saturate( descriptor, x )"><span class="secnum">5.1.25</span> Saturate( descriptor, x )</a></li><li><span class="item-toggle-none"></span><a href="#add-saturate" title="AddSaturate( descriptor )( x, y )"><span class="secnum">5.1.26</span> AddSaturate( descriptor )( x, y )</a></li><li><span class="item-toggle-none"></span><a href="#sub-saturate" title="SubSaturate( descriptor )( x, y )"><span class="secnum">5.1.27</span> SubSaturate( descriptor )( x, y )</a></li><li><span class="item-toggle-none"></span><a href="#bitwise-op" title="BitwiseOp( @ )( lval, rval )"><span class="secnum">5.1.28</span> BitwiseOp( @ )( lval, rval )</a></li><li><span class="item-toggle-none"></span><a href="#array-join" title="ArrayJoin( array, separator )"><span class="secnum">5.1.29</span> ArrayJoin( array, separator )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#simd-constructor" title="Constructor properties SIMDConstructor of the SIMD object"><span class="secnum">5.2</span> Constructor properties <var>SIMD</var>Constructor of the SIMD object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#simd-wrapper" title="SIMDConstructor( ...values )"><span class="secnum">5.2.1</span> <var>SIMD</var>Constructor( ...values )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#constructor-properties" title="Properties of the SIMDConstructor constructors"><span class="secnum">5.3</span> Properties of the <var>SIMD</var>Constructor constructors</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#simd-splat" title="SIMDConstructor.splat(n)"><span class="secnum">5.3.1</span> <var>SIMD</var>Constructor.splat(n)</a></li><li><span class="item-toggle-none"></span><a href="#simd-check" title="SIMDConstructor.check(a)"><span class="secnum">5.3.2</span> <var>SIMD</var>Constructor.check(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-add" title="SIMDConstructor.add(a, b)"><span class="secnum">5.3.3</span> <var>SIMD</var>Constructor.add(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-sub" title="SIMDConstructor.sub(a, b)"><span class="secnum">5.3.4</span> <var>SIMD</var>Constructor.sub(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-mul" title="SIMDConstructor.mul(a, b)"><span class="secnum">5.3.5</span> <var>SIMD</var>Constructor.mul(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-div" title="SIMDConstructor.div(a, b)"><span class="secnum">5.3.6</span> <var>SIMD</var>Constructor.div(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-max" title="SIMDConstructor.max(a, b)"><span class="secnum">5.3.7</span> <var>SIMD</var>Constructor.max(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-min" title="SIMDConstructor.min(a, b)"><span class="secnum">5.3.8</span> <var>SIMD</var>Constructor.min(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-max-num" title="SIMDConstructor.maxNum(a, b)"><span class="secnum">5.3.9</span> <var>SIMD</var>Constructor.maxNum(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-min-num" title="SIMDConstructor.minNum(a, b)"><span class="secnum">5.3.10</span> <var>SIMD</var>Constructor.minNum(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-neg" title="SIMDConstructor.neg(a)"><span class="secnum">5.3.11</span> <var>SIMD</var>Constructor.neg(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-sqrt" title="SIMDConstructor.sqrt(a)"><span class="secnum">5.3.12</span> <var>SIMD</var>Constructor.sqrt(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-reciprocal-approximation" title="SIMDConstructor.reciprocalApproximation(a)"><span class="secnum">5.3.13</span> <var>SIMD</var>Constructor.reciprocalApproximation(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-reciprocal-sqrt-approximation" title="SIMDConstructor.reciprocalSqrtApproximation(a)"><span class="secnum">5.3.14</span> <var>SIMD</var>Constructor.reciprocalSqrtApproximation(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-abs" title="SIMDConstructor.abs(a)"><span class="secnum">5.3.15</span> <var>SIMD</var>Constructor.abs(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-and" title="SIMDConstructor.and(a, b)"><span class="secnum">5.3.16</span> <var>SIMD</var>Constructor.and(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-xor" title="SIMDConstructor.xor(a, b)"><span class="secnum">5.3.17</span> <var>SIMD</var>Constructor.xor(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-or" title="SIMDConstructor.or(a, b)"><span class="secnum">5.3.18</span> <var>SIMD</var>Constructor.or(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-not" title="SIMDConstructor.not(a)"><span class="secnum">5.3.19</span> <var>SIMD</var>Constructor.not(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-less-than" title="SIMDConstructor.lessThan(a, b)"><span class="secnum">5.3.20</span> <var>SIMD</var>Constructor.lessThan(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-less-than-or-equal" title="SIMDConstructor.lessThanOrEqual(a, b)"><span class="secnum">5.3.21</span> <var>SIMD</var>Constructor.lessThanOrEqual(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-greater-than" title="SIMDConstructor.greaterThan(a, b)"><span class="secnum">5.3.22</span> <var>SIMD</var>Constructor.greaterThan(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-greater-than-or-equal" title="SIMDConstructor.greaterThanOrEqual(a, b)"><span class="secnum">5.3.23</span> <var>SIMD</var>Constructor.greaterThanOrEqual(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-equal" title="SIMDConstructor.equal(a, b)"><span class="secnum">5.3.24</span> <var>SIMD</var>Constructor.equal(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-not-equal" title="SIMDConstructor.notEqual(a, b)"><span class="secnum">5.3.25</span> <var>SIMD</var>Constructor.notEqual(a, b)</a></li><li><span class="item-toggle-none"></span><a href="#simd-any-true" title="SIMDConstructor.anyTrue(a)"><span class="secnum">5.3.26</span> <var>SIMD</var>Constructor.anyTrue(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-all-true" title="SIMDConstructor.allTrue(a)"><span class="secnum">5.3.27</span> <var>SIMD</var>Constructor.allTrue(a)</a></li><li><span class="item-toggle-none"></span><a href="#simd-select" title="SIMDConstructor.select( selector, a, b )"><span class="secnum">5.3.28</span> <var>SIMD</var>Constructor.select( selector, a, b )</a></li><li><span class="item-toggle-none"></span><a href="#simd-add-saturate" title="SIMDConstructor.addSaturate( a, b )"><span class="secnum">5.3.29</span> <var>SIMD</var>Constructor.addSaturate( a, b )</a></li><li><span class="item-toggle-none"></span><a href="#simd-sub-saturate" title="SIMDConstructor.subSaturate( a, b )"><span class="secnum">5.3.30</span> <var>SIMD</var>Constructor.subSaturate( a, b )</a></li><li><span class="item-toggle-none"></span><a href="#simd-shift-left-by-scalar" title="SIMDConstructor.shiftLeftByScalar( a, bits )"><span class="secnum">5.3.31</span> <var>SIMD</var>Constructor.shiftLeftByScalar( a, bits )</a></li><li><span class="item-toggle-none"></span><a href="#simd-shift-right-by-scalar" title="SIMDConstructor.shiftRightByScalar( a, bits )"><span class="secnum">5.3.32</span> <var>SIMD</var>Constructor.shiftRightByScalar( a, bits )</a></li><li><span class="item-toggle-none"></span><a href="#simd-extract-lane" title="SIMDConstructor.extractLane( simd, lane )"><span class="secnum">5.3.33</span> <var>SIMD</var>Constructor.extractLane( simd, lane )</a></li><li><span class="item-toggle-none"></span><a href="#simd-replace-lane" title="SIMDConstructor.replaceLane( simd, lane, value )"><span class="secnum">5.3.34</span> <var>SIMD</var>Constructor.replaceLane( simd, lane, value )</a></li><li><span class="item-toggle-none"></span><a href="#simd-store-function" title="SIMDConstructor.store( tarray, index, simd )"><span class="secnum">5.3.35</span> <var>SIMD</var>Constructor.store( tarray, index, simd )</a></li><li><span class="item-toggle-none"></span><a href="#simd-store1" title="SIMDConstructor.store1( tarray, index, simd )"><span class="secnum">5.3.36</span> <var>SIMD</var>Constructor.store1( tarray, index, simd )</a></li><li><span class="item-toggle-none"></span><a href="#simd-store2" title="SIMDConstructor.store2( tarray, index, simd )"><span class="secnum">5.3.37</span> <var>SIMD</var>Constructor.store2( tarray, index, simd )</a></li><li><span class="item-toggle-none"></span><a href="#simd-store3" title="SIMDConstructor.store3( tarray, index, simd )"><span class="secnum">5.3.38</span> <var>SIMD</var>Constructor.store3( tarray, index, simd )</a></li><li><span class="item-toggle-none"></span><a href="#simd-load-function" title="SIMDConstructor.load( tarray, index )"><span class="secnum">5.3.39</span> <var>SIMD</var>Constructor.load( tarray, index )</a></li><li><span class="item-toggle-none"></span><a href="#simd-load1" title="SIMDConstructor.load1(tarray, index)"><span class="secnum">5.3.40</span> <var>SIMD</var>Constructor.load1(tarray, index)</a></li><li><span class="item-toggle-none"></span><a href="#simd-load2" title="SIMDConstructor.load2(tarray, index)"><span class="secnum">5.3.41</span> <var>SIMD</var>Constructor.load2(tarray, index)</a></li><li><span class="item-toggle-none"></span><a href="#simd-load3" title="SIMDConstructor.load3(tarray, index)"><span class="secnum">5.3.42</span> <var>SIMD</var>Constructor.load3(tarray, index)</a></li><li><span class="item-toggle-none"></span><a href="#simd-to-timd" title="SIMDConstructor.fromTIMDBits( value )"><span class="secnum">5.3.43</span> <var>SIMD</var>Constructor.from<var>TIMD</var>Bits( value )</a></li><li><span class="item-toggle-none"></span><a href="#simd-to-timd-logical" title="SIMDConstructor.fromTIMD( value )"><span class="secnum">5.3.44</span> <var>SIMD</var>Constructor.from<var>TIMD</var>( value )</a></li><li><span class="item-toggle-none"></span><a href="#swizzle" title="SIMDConstructor.swizzle( a, ...lanes )"><span class="secnum">5.3.45</span> <var>SIMD</var>Constructor.swizzle( a, ...lanes )</a></li><li><span class="item-toggle-none"></span><a href="#shuffle" title="SIMDConstructor.shuffle( a, b, ...lanes )"><span class="secnum">5.3.46</span> <var>SIMD</var>Constructor.shuffle( a, b, ...lanes )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#simd-proto" title="The SIMDConstructor.prototype"><span class="secnum">5.4</span> The <var>SIMD</var>Constructor.prototype</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#simd-proto-constructor" title="SIMDConstructor.prototype.constructor"><span class="secnum">5.4.1</span> <var>SIMD</var>Constructor.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#simd-prototype-valueof" title="SIMDConstructor.prototype.valueOf()"><span class="secnum">5.4.2</span> <var>SIMD</var>Constructor.prototype.valueOf()</a></li><li><span class="item-toggle-none"></span><a href="#simd-prototype-tolocalestring" title="SIMDConstructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )"><span class="secnum">5.4.3</span> <var>SIMD</var>Constructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )</a></li><li><span class="item-toggle-none"></span><a href="#simd-prototype-tostring" title="SIMDConstructor.prototype.toString()"><span class="secnum">5.4.4</span> <var>SIMD</var>Constructor.prototype.toString()</a></li><li><span class="item-toggle-none"></span><a href="#simd-to-string-tag" title="SIMDConstructor.prototype [ @@toStringTag ]"><span class="secnum">5.4.5</span> <var>SIMD</var>Constructor.prototype [ @@toStringTag ]</a></li><li><span class="item-toggle-none"></span><a href="#simd-to-primitive" title="SIMDConstructor.prototype [ @@toPrimitive ] ( hint )"><span class="secnum">5.4.6</span> <var>SIMD</var>Constructor.prototype [ @@toPrimitive ] ( hint )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#simd-descriptors" title="SIMD type descriptors"><span class="secnum">5.5</span> SIMD type descriptors</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#serialize-float32" title="SerializeFloat32( block, offset, n, isLittleEndian )"><span class="secnum">5.5.1</span> SerializeFloat32( block, offset, n, isLittleEndian )</a></li><li><span class="item-toggle-none"></span><a href="#deserialize-float32" title="DeserializeFloat32( block, offset, isLittleEndian )"><span class="secnum">5.5.2</span> DeserializeFloat32( block, offset, isLittleEndian )</a></li><li><span class="item-toggle-none"></span><a href="#serialize-int" title="SerializeInt( descriptor )( block, offset, n, isLittleEndian )"><span class="secnum">5.5.3</span> SerializeInt( descriptor )( block, offset, n, isLittleEndian )</a></li><li><span class="item-toggle-none"></span><a href="#deserialize-int" title="DeserializeInt( descriptor )( block, offset, isLittleEndian )"><span class="secnum">5.5.4</span> DeserializeInt( descriptor )( block, offset, isLittleEndian )</a></li></ol></li></ol></li></ol></div></div><div id="spec-container"><h1 class="first">SIMD.js specification v0.9</h1>
<emu-intro id="intro">
<h1>Introduction</h1>
<p>This proposal adds SIMD types and operations to ECMAScript. The proposal adds new primitive types <emu-xref aoid="Float32x4" id="_ref_0"><a href="#float32x4">Float32x4</a></emu-xref>, etc, together with wrappers and a definition of their behavior in the language. The current proposal should form a full first draft with all functions and types included.</p>

<p>One problem that this spec aims to solve is to define equality for SIMD values. Before the spec was written, prior implementations used object identity-based equality. However, maintaining object identity puts a big burden on compilers to maintain this identity through operations, where they would rather be able to duplicate and de-duplicate SIMD values arbitrarily based on algebraic identities. By making SIMD values into primitive types with structural equality, compilers are given more freedom.</p>

<p>Ideally, SIMD values will fit into a larger value types proposal. Such a proposal would be a bit more involved, but good work has already been done in that direction. This document describes SIMD without a larger value type system, but it aims to be consistent with how value types might work, and once value types are described in more detail, it will be great to refactor this text by just explaining SIMD in terms of value types. On the other hand, this proposal gives a vehicle to work out some of the issues in value types and can be used as a guide for future value type designs.</p>

<p>This document is organized in terms of where changes would be made to the ES2015 spec. Although ecmarkup generates numbering at the beginning of headers, these won't correspond to the numbering within the existing ECMAScript spec, so I've included a matching numbering in parentheses afterwards, referring to the ES2015 spec.</p>

<p>In this text, <var>SIMD</var> is used to refer to the various SIMD types: <emu-xref aoid="Float32x4" id="_ref_1"><a href="#float32x4">Float32x4</a></emu-xref>, <emu-xref aoid="Int32x4" id="_ref_2"><a href="#int32x4">Int32x4</a></emu-xref>, <emu-xref aoid="Int16x8" id="_ref_3"><a href="#int16x8">Int16x8</a></emu-xref> <emu-xref aoid="Int8x16" id="_ref_4"><a href="#int8x16">Int8x16</a></emu-xref>, <emu-xref aoid="Uint32x4" id="_ref_5"><a href="#uint32x4">Uint32x4</a></emu-xref>, <emu-xref aoid="Uint16x8" id="_ref_6"><a href="#uint16x8">Uint16x8</a></emu-xref> <emu-xref aoid="Uint8x16" id="_ref_7"><a href="#uint8x16">Uint8x16</a></emu-xref>, <emu-xref aoid="Bool32x4" id="_ref_8"><a href="#bool32x4">Bool32x4</a></emu-xref>, <emu-xref aoid="Bool16x8" id="_ref_9"><a href="#bool16x8">Bool16x8</a></emu-xref> and <emu-xref aoid="Bool8x16" id="_ref_10"><a href="#bool8x16">Bool8x16</a></emu-xref>. Similarly to Number, <var>SIMD</var> is used to refer to both the type  <em>and</em> the wrapper constructor object. This looks a bit confusing, but it provides the most regularity, as an aim of this specification is to make SIMD types primitives that operate analogously to the existing primitives, rather than a new, exotic sort of thing. To reduce ambiguity, the wrapper constructor is usually referred to as <var>SIMD</var>Constructor, and the type is referred to as <var>SIMD</var>Type. SIMD types are associated with a descriptor spec object, called <var>SIMD</var>Descriptor.</p>

<p><strong>Please file any issues  <a href="https://github.com/tc39/ecmascript_simd/issues">here</a>!</strong> The authoritative copy of this file is in  <a href="https://github.com/tc39/ecmascript_simd/blob/master/tc39/spec.html">in the simd.js repo</a>; to propose changes to this spec, please send pull requests against that repository. Daniel Ehrenberg (littledan) is responsible for watching for changes to that file, generating the output with ecmarkup and pushing it to  <a href="http://tc39.github.io/ecmascript_simd/">the official rendered location</a>.</p>

<p>Because this document is in spec order, rather than written for direct readability, the logical starting point is actually  <a href="#simd">halfway down</a>.</p>

<p>Related links:</p>

<ul>
<li><a href="https://github.com/nikomatsakis/typed-objects-explainer/blob/master/valuetypes.md">Value types proposal</a></li>
<li><a href="https://github.com/tc39/ecmascript_simd/blob/master/src/ecmascript_simd.js">SIMD polyfill</a></li>
<li><a href="https://github.com/tc39/ecmascript_simd/issues/157">Bug about SIMD.js value semantics</a></li>
</ul>

Changelog:

<ul>
<li>v0.1: Initial proposal based on SIMD values held in Data Blocks</li>
<li>v0.2:

<ul>
<li>SIMD values are explained as Lists of Numbers, and serialized/deserialized only on loads and stores to TypedArrays, and casts.</li>
<li>SIMD values point to a type descriptor, not to the wrapper constructor, which makes cross-<emu-xref href="#realm"><a href="https://tc39.github.io/ecma262/#realm">realm</a></emu-xref> access more straightforward.</li>
<li>Add all SIMD types, more SIMD operations and all DataView operations.</li>
</ul>
</li>
<li>v0.3: Add more operations, fix some errors and clarify wording.</li>
<li>v0.4: Fix various bugs, mostly reported by rwaldron.</li>
<li>v0.4.1: Refactor definitions for integer types to reduce duplication.</li>
<li>v0.5: Logical and bitwise operations; Int64x2.</li>
<li>v0.5.1: Logical casts between types, like SIMD.float32x4.fromInt32x4; Less exact definition for reciprocalApproximation, reciprocalSqrtApproximation</li>
<li>v0.5.2: Saturating arithmetic; fix mul mis-spec.</li>
<li>v0.5.3: Remove mention of signalling NaN (matches ES6).</li>
<li>v0.5.4: Better formatting for modifications of existing algorithms.</li>
<li>v0.5.5: toLocaleString, shifts, saturating functions only on int16 and smaller, sumOfAbsoluteDifferences. This is the first version to include all functions.</li>
<li>v0.5.6: Fix a few typos, added notes, removed DataView methods, store returns value.</li>
<li>v0.6: Remove Int64x2 and add boolean vectors.</li>
<li>v0.6.1: Relax behavior on subnormals, float to int conversion throws on out of bounds, shift does not mask.</li>
<li>v0.7: Remove Float64x2, Bool64x2, {load,store}[123], selectBits (could be in phase 2); add unsigned operations and sum of absolute differences operations; minor fix in 'shift' definition; clarify what the <emu-xref aoid="SIMD object" id="_ref_11"><a href="#simd-object-def">SIMD object</a></emu-xref> is.</li>
<li>v0.7.1: Add back in {load,store}[123], make <emu-xref aoid="ToString" id="_ref_12"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>() homoiconic.</li>
<li>v0.7.2: Fix shiftRightArithmetic, add @@toPrimitive, do implicit coercion for shift bits.</li>
<li>v0.7.3: Coerce lane arguments, no bitcast on bool, fix typo in .check() and .valueOf(), no constructing wrappers, fix denormal behavior to be deterministic and match hardware, fix shuffle definition, define arithmetic operations only on numeric types, fix up ES2015 links.</li>
<li>v0.8: Separate signed and unsigned integer types</li>
<li>v0.8.1: Minor language fixes and cleanups from review; no behavior changes</li>
<li>v0.8.2: Remove unsignedExtractLane, remove equals, notEquals, swizzle and shuffle from boolean vectors, improve internal algorithm notation, restrict rest argument usage, toString <code>", "</code></li>
<li>v0.8.3: Better explanations and changes based on editor review</li>
<li>v0.8.4: Merge signed and unsigned shifts into one function name</li>
<li>v0.9: Remove horizontalSum/absoluteDifference; improve phrasing based on reviews</li>
<li>v0.9.1: Throw on NaN in logical conversion. Limit logical conversion to be between Integer and Float types only</li>
<li>v0.9.2: Changed the *shiftByScalar semantics to used the same masked semantics that the scalar shifts are using</li>
</ul>
</emu-intro>

<emu-clause id="terms-and-defs">
<h1><span class="secnum">1</span>Terms and definitions (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values">4.3</a>)</h1>

<emu-clause id="primitive-def">
<h1><span class="secnum">1.1</span>primitive value (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-primitive-value">4.3.2</a>)</h1>
member of one of the types Undefined, Null, Boolean, Number, Symbol, String,  <ins>or one of the SIMD types</ins> as defined in clause 6

</emu-clause>

<emu-clause id="simd-meta-var-def">
<h1><span class="secnum">1.2</span><var>SIMD</var></h1>
a meta-variable ranging over all SIMD types, namely <emu-xref aoid="Float32x4" id="_ref_13"><a href="#float32x4">Float32x4</a></emu-xref>, <emu-xref aoid="Int32x4" id="_ref_14"><a href="#int32x4">Int32x4</a></emu-xref>, <emu-xref aoid="Int16x8" id="_ref_15"><a href="#int16x8">Int16x8</a></emu-xref> <emu-xref aoid="Int8x16" id="_ref_16"><a href="#int8x16">Int8x16</a></emu-xref>, <emu-xref aoid="Uint32x4" id="_ref_17"><a href="#uint32x4">Uint32x4</a></emu-xref>, <emu-xref aoid="Uint16x8" id="_ref_18"><a href="#uint16x8">Uint16x8</a></emu-xref>, <emu-xref aoid="Uint8x16" id="_ref_19"><a href="#uint8x16">Uint8x16</a></emu-xref>, <emu-xref aoid="Bool32x4" id="_ref_20"><a href="#bool32x4">Bool32x4</a></emu-xref>, <emu-xref aoid="Bool16x8" id="_ref_21"><a href="#bool16x8">Bool16x8</a></emu-xref> and <emu-xref aoid="Bool8x16" id="_ref_22"><a href="#bool8x16">Bool8x16</a></emu-xref>.

</emu-clause>

<emu-clause id="simd-meta-var-def">
<h1><span class="secnum">1.3</span><var>SIMD</var>Descriptor</h1>
The  <a href="#simd-descriptors">type descriptor</a> for the particular SIMD type  <a href="#simd-meta-var-def"><var>SIMD</var></a>.

</emu-clause>

<emu-clause id="simd-type-def">
<h1><span class="secnum">1.4</span>SIMD types</h1>
family of types which each consist of a set of SIMD vector values.

<emu-note><span class="note">Note</span><div class="note-contents">For example, the <emu-xref aoid="Float32x4" id="_ref_23"><a href="#float32x4">Float32x4</a></emu-xref> type consists of the set of vectors of 4 32-bit floats.</div></emu-note>
</emu-clause>

<emu-clause id="simd-value-def" aoid="SIMD value">
<h1><span class="secnum">1.5</span>SIMD value</h1>
Member of a particular SIMD type. These values are represented as described in the  <a href="#simd">SIMD</a> section. SIMD values are primitives, and they are represented as records with two fields.

</emu-clause>

<emu-clause id="simd-object-def" aoid="SIMD object">
<h1><span class="secnum">1.6</span>SIMD object</h1>
For a particular SIMD type, a member of the Object type which has a [[SIMDData]] internal slot.

</emu-clause>

<emu-clause id="simd-type-descriptor-def">
<h1><span class="secnum">1.7</span>SIMD type descriptor</h1>
A specification-internal record describing the behavior and properties of a SIMD type, described in the %SIMD% section. The meta-variable <var>SIMD</var>Descriptor ranges over type descriptors.

</emu-clause>

<emu-clause id="simd-boolean-type">
<h1><span class="secnum">1.8</span>SIMD boolean type</h1>
A SIMD type whose values are booleans, namely <emu-xref aoid="Bool32x4" id="_ref_24"><a href="#bool32x4">Bool32x4</a></emu-xref>, <emu-xref aoid="Bool16x8" id="_ref_25"><a href="#bool16x8">Bool16x8</a></emu-xref> and <emu-xref aoid="Bool8x16" id="_ref_26"><a href="#bool8x16">Bool8x16</a></emu-xref>.

</emu-clause>

<emu-clause id="simd-integer-type">
<h1><span class="secnum">1.9</span>SIMD integer type</h1>
A SIMD type whose values are integers, namely <emu-xref aoid="Int32x4" id="_ref_27"><a href="#int32x4">Int32x4</a></emu-xref>, <emu-xref aoid="Int16x8" id="_ref_28"><a href="#int16x8">Int16x8</a></emu-xref>, <emu-xref aoid="Int8x16" id="_ref_29"><a href="#int8x16">Int8x16</a></emu-xref>, <emu-xref aoid="Uint32x4" id="_ref_30"><a href="#uint32x4">Uint32x4</a></emu-xref>, <emu-xref aoid="Uint16x8" id="_ref_31"><a href="#uint16x8">Uint16x8</a></emu-xref>, and <emu-xref aoid="Uint8x16" id="_ref_32"><a href="#uint8x16">Uint8x16</a></emu-xref>.

</emu-clause>

<emu-clause id="simd-floating-point-type">
<h1><span class="secnum">1.10</span>SIMD floating-point type</h1>
A SIMD type whose values are floating-point numbers, namely <emu-xref aoid="Float32x4" id="_ref_33"><a href="#float32x4">Float32x4</a></emu-xref>.

</emu-clause>

<emu-clause id="simd-signed-integer-type">
<h1><span class="secnum">1.11</span>SIMD signed integer type</h1>
A SIMD type whose values are signed integers, namely <emu-xref aoid="Int32x4" id="_ref_34"><a href="#int32x4">Int32x4</a></emu-xref>, <emu-xref aoid="Int16x8" id="_ref_35"><a href="#int16x8">Int16x8</a></emu-xref> and <emu-xref aoid="Int8x16" id="_ref_36"><a href="#int8x16">Int8x16</a></emu-xref>.

</emu-clause>

<emu-clause id="simd-unsigned-integer-type">
<h1><span class="secnum">1.12</span>SIMD unsigned integer type</h1>
A SIMD type whose values are unsigned integers, namely <emu-xref aoid="Uint32x4" id="_ref_37"><a href="#uint32x4">Uint32x4</a></emu-xref>, <emu-xref aoid="Uint16x8" id="_ref_38"><a href="#uint16x8">Uint16x8</a></emu-xref>, and <emu-xref aoid="Uint8x16" id="_ref_39"><a href="#uint8x16">Uint8x16</a></emu-xref>.

</emu-clause>
</emu-clause>

<emu-clause id="types">
<h1><span class="secnum">2</span>ECMAScript Data Types and Values (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values">6</a>)</h1>
<emu-clause id="all-types">
<h1><span class="secnum">2.1</span>ECMAScript language types (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types">6.1</a>)</h1>
<emu-clause id="object-type">
<h1><span class="secnum">2.1.1</span>The Object Type (<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object-type">6.1.7</a>)</h1>
<emu-clause id="intrinsics">
<h1><span class="secnum">2.1.1.1</span>Well-Known Intrinsic Objects (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-well-known-intrinsic-objects">6.1.7.4</a>)</h1>

<emu-table><figure><figcaption>Table 1: Well-known Intrinsic Objects</figcaption>
<table class="real-table">
<tbody><tr>
<th>Intrinsic Name</th>
<th>Global Name</th>
<th>ECMAScript Language Association</th>
</tr>

<tr>
<td>%SIMD%</td>
<td><code>SIMD</code></td>
<td>The  <a href="#simd"><code>SIMD</code></a> object

</td></tr>

<tr>
<td>%SIMD_Float32x4%</td>
<td><code>SIMD.Float32x4</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Float32x4</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Float32x4Prototype%</td>
<td><code>SIMD.Float32x4.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Float32x4%</a></td>
</tr>

<tr>
<td>%SIMD_Int32x4%</td>
<td><code>SIMD.Int32x4</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Int32x4</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Int32x4Prototype%</td>
<td><code>SIMD.Int32x4.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Int32x4%</a></td>
</tr>

<tr>
<td>%SIMD_Int16x8%</td>
<td><code>SIMD.Int16x8</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Int16x8</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Int16x8Prototype%</td>
<td><code>SIMD.Int16x8.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Int16x8%</a></td>
</tr>

<tr>
<td>%SIMD_Int8x16%</td>
<td><code>SIMD.Int8x16</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Int8x16</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Int8x16Prototype%</td>
<td><code>SIMD.Int8x16.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Int8x16%</a></td>
</tr>

<tr>
<td>%SIMD_Uint32x4%</td>
<td><code>SIMD.Uint32x4</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Uint32x4</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Uint32x4Prototype%</td>
<td><code>SIMD.Uint32x4.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Uint32x4%</a></td>
</tr>

<tr>
<td>%SIMD_Uint16x8%</td>
<td><code>SIMD.Uint16x8</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Uint16x8</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Uint16x8Prototype%</td>
<td><code>SIMD.Uint16x8.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Uint16x8%</a></td>
</tr>

<tr>
<td>%SIMD_Uint8x16%</td>
<td><code>SIMD.Uint8x16</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Uint8x16</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Uint8x16Prototype%</td>
<td><code>SIMD.Uint8x16.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Uint8x16%</a></td>
</tr>

<tr>
<td>%SIMD_Bool32x4%</td>
<td><code>SIMD.Bool32x4</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Bool32x4</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Bool32x4Prototype%</td>
<td><code>SIMD.Bool32x4.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Bool32x4%</a></td>
</tr>

<tr>
<td>%SIMD_Bool16x8%</td>
<td><code>SIMD.Bool16x8</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Bool16x8</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Bool16x8Prototype%</td>
<td><code>SIMD.Bool16x8.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Bool16x8%</a></td>
</tr>

<tr>
<td>%SIMD_Bool8x16%</td>
<td><code>SIMD.Bool8x16</code></td>
<td>The  <a href="#simd-constructor"><code>SIMD.Bool8x16</code></a> constructor</td>
</tr>

<tr>
<td>%SIMD_Bool8x16Prototype%</td>
<td><code>SIMD.Bool8x16.prototype</code></td>
<td>The initial value of the prototype data property of  <a href="#simd-constructor">%SIMD.Bool8x16%</a></td>
</tr>

</tbody></table>


</figure></emu-table></emu-clause>
</emu-clause>
</emu-clause>

<emu-clause id="simd-types">
<h1><span class="secnum">2.2</span>SIMD types</h1>
A <emu-xref aoid="SIMD value" id="_ref_40"><a href="#simd-value-def">SIMD value</a></emu-xref> is a homogeneous vector of Numbers or Booleans, possibly from a restricted range. Each <emu-xref aoid="SIMD value" id="_ref_41"><a href="#simd-value-def">SIMD value</a></emu-xref> is represented as a record with the following immutable fields:

<ul>
<li>[[SIMDTypeDescriptor]], which refers to the type descriptor for the type.</li>
<li>[[SIMDElements]], which is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of values representing the SIMD contents.</li>
</ul>
<emu-note><span class="note">Note 1</span><div class="note-contents">The [[SIMDTypeDescriptor]] field effectively determines its type. The SIMD type descriptors are defined in  <a href="#simd-descriptor-table">a table</a>.</div></emu-note>
<emu-note><span class="note">Note 2</span><div class="note-contents">A list which is in the [[SIMDElements]] of a <emu-xref aoid="SIMD value" id="_ref_42"><a href="#simd-value-def">SIMD value</a></emu-xref> field is never modified.</div></emu-note>
<emu-note><span class="note">Note 3</span><div class="note-contents">[[SIMDElements]] is a list of Number values for integer and floating point SIMD types, and Boolean values for boolean SIMD types.</div></emu-note>

SIMD type descriptors are records with the following fields:

<ul>
<li>[[VectorLength]]: The number of elements present in a <emu-xref aoid="SIMD value" id="_ref_43"><a href="#simd-value-def">SIMD value</a></emu-xref> of the type</li>
<li>[[ElementSize]]: Size in bytes of each element</li>
<li>[[Cast]]: An internal algorithm for down-casting a Number to the precision representable in the SIMD type</li>
<li>[[SerializeElement]]: An internal algorithm for writing a Number as [[ElementSize]] bytes</li>
<li>[[DeserializeElement]]: An internal algorithm for converting [[ElementSize]] bytes into a Number</li>
<li>[[ElementMax]]: The maximum value included in the range representable by the element type</li>
<li>[[ElementMin]]: The minimum value included in the range representable by the element type</li>
</ul>

<p>Each SIMD type descriptor is listed in  <a href="#simd-descriptor-table">this table</a>. All SIMD types are either  <a href="#simd-integer-type">integer SIMD types</a>,  <a href="#simd-boolean-type">boolean SIMD types</a> or or  <a href="#simd-floating-point-type">floating point SIMD types</a>. Certain operations are defined on either integer, boolean or floating point types, and integer types are be signed or unsigned, and this is noted in the table.</p>

The [[ElementMax]], [[ElementMin]], [[ElementSize]], [[SerializeElement]] and [[DeserializeElement]] fields are optional, and defined only on certain SIMD types. Operations which use these fields have been defined only on the types which have them.

<emu-note><span class="note">Note 4</span><div class="note-contents">Many SIMD type descriptors have a [[Cast]] algorithm which outputs a Number. However, this Number is often in a restricted range, and implementations may use a different representation internally.</div></emu-note>

<emu-clause id="float32x4" aoid="Float32x4">
<h1><span class="secnum">2.2.1</span>Float32x4</h1>
<code>Float32x4</code> is a SIMD type representing four 32-bit floating point values. Float32x4 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Float32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Float32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="int32x4" aoid="Int32x4">
<h1><span class="secnum">2.2.2</span>Int32x4</h1>
<code>Int32x4</code> is a SIMD type representing four 32-bit signed integer values. Int32x4 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Int32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Int32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="int16x8" aoid="Int16x8">
<h1><span class="secnum">2.2.3</span>Int16x8</h1>
<code>Int16x8</code> is a SIMD type representing eight 16-bit signed integer values. Int16x8 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Int16x8</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Int16x8 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="int8x16" aoid="Int8x16">
<h1><span class="secnum">2.2.4</span>Int8x16</h1>
<code>Int8x16</code> is a SIMD type representing sixteen 8-bit signed integer values. Int8x16 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Int8x16</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Int8x16 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="uint32x4" aoid="Uint32x4">
<h1><span class="secnum">2.2.5</span>Uint32x4</h1>
<code>Uint32x4</code> is a SIMD type representing four 32-bit unsigned integer values. Uint32x4 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Uint32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Uint32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="uint16x8" aoid="Uint16x8">
<h1><span class="secnum">2.2.6</span>Uint16x8</h1>
<code>Uint16x8</code> is a SIMD type representing eight 16-bit unsigned integer values. Uint16x8 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Uint16x8</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Uint16x8 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="uint8x16" aoid="Uint8x16">
<h1><span class="secnum">2.2.7</span>Uint8x16</h1>
<code>Uint8x16</code> is a SIMD type representing sixteen 8-bit unsigned integer values. Uint8x16 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Uint8x16</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Uint8x16 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="bool32x4" aoid="Bool32x4">
<h1><span class="secnum">2.2.8</span>Bool32x4</h1>
<code>Bool32x4</code> is a SIMD type representing four boolean values, as an intermediate value in manipulating 128-bit vectors. Bool32x4 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Bool32x4</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Bool32x4 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="bool16x8" aoid="Bool16x8">
<h1><span class="secnum">2.2.9</span>Bool16x8</h1>
<code>Bool16x8</code> is a SIMD type representing eight boolean values, as an intermediate value in manipulating 128-bit vectors. Bool16x8 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Bool16x8</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Bool16x8 SIMD type descriptor</a>.

</emu-clause>

<emu-clause id="bool8x16" aoid="Bool8x16">
<h1><span class="secnum">2.2.10</span>Bool8x16</h1>
<code>Bool8x16</code> is a SIMD type representing sixteen boolean values, as an intermediate value in manipulating 128-bit vectors. Bool8x16 values can be created using the [[Call]] operation on the  <a href="#simd-constructor">SIMD.Bool8x16</a> object. Its behavior as a SIMD type is defined by the  <a href="#simd-descriptor-table">Bool8x16 SIMD type descriptor</a>.

</emu-clause>

</emu-clause>
</emu-clause>

<emu-clause id="abstract-operations">
<h1><span class="secnum">3</span>Abstract Operations (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-operations">7</a>)</h1>

<emu-clause id="type-conversion">
<h1><span class="secnum">3.1</span>Type Conversion (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-type-conversion">7.1</a>)</h1>

<emu-clause id="to-primitive">
<h1><span class="secnum">3.1.1</span>ToPrimitive ( input [, PreferredType] ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive">7.1.1</a>)</h1>

<strong>Argument type</strong>: <var>SIMD</var>Type

<br>
<strong>Result</strong>: return <var>input</var>

</emu-clause>

<emu-clause id="to-boolean">
<h1><span class="secnum">3.1.2</span>ToBoolean ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toboolean">7.1.2</a>)</h1>

<strong>Argument type</strong>: <var>SIMD</var>Type

<br>
<strong>Result</strong>: return <emu-val>true</emu-val>

</emu-clause>

<emu-clause id="to-number">
<h1><span class="secnum">3.1.3</span>ToNumber ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber">7.1.3</a>)</h1>

<strong>Argument type</strong>: <var>SIMD</var>Type

<br>
<strong>Result</strong>: throw a <emu-val>TypeError</emu-val> exception

</emu-clause>

<emu-clause id="to-string">
<h1><span class="secnum">3.1.4</span>ToString ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-tostring">7.1.12</a>)</h1>

<strong>Argument type</strong>: <var>SIMD</var>Type

<br>
<strong>Result</strong>:

<emu-alg><ol><li>Let <var>elements</var> be <emu-xref aoid="CreateArrayFromList" id="_ref_44"><a href="https://tc39.github.io/ecma262/#sec-createarrayfromlist">CreateArrayFromList</a></emu-xref>(<var>argument</var>.[[SIMDElements]]).</li><li>Let <var>t</var> be the string <code>"</code><var>SIMD</var><code>"</code>, e.g., <code>"Float32x4"</code>.</li><li>Let e be <emu-xref aoid="ArrayJoin" id="_ref_45"><a href="#array-join">ArrayJoin</a></emu-xref>(<var>elements</var>, ", ").</li><li>Return a new String value computed by concatenating the values "SIMD.", <var>t</var>, "(", <var>e</var>, and ")".</li></ol></emu-alg>

<emu-note><span class="note">Note</span><div class="note-contents">On a SIMD vector v, <code>eval(v.toString()) == v</code> in the initial <emu-xref href="#global-environment"><a href="https://tc39.github.io/ecma262/#global-environment">global environment</a></emu-xref>, except that NaNs may be canonicalized.</div></emu-note>
</emu-clause>

<emu-clause id="to-object">
<h1><span class="secnum">3.1.5</span>ToObject ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-toobject">7.1.13</a>)</h1>

<strong>Argument type</strong>: <var>SIMD</var>Type

<br>
<strong>Result</strong>: Return a new %<var>SIMD</var>Constructor% object whose [[SIMDData]] internal slot is set to <var>argument</var>.

</emu-clause>
</emu-clause>

<emu-clause id="require-object-coercible">
<h1><span class="secnum">3.2</span>RequireObjectCoercible ( argument ) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-requireobjectcoercible">7.2.1</a>)</h1>

<strong>Argument type</strong>: <var>SIMD</var>Type

<br>
<strong>Result</strong>: return <var>argument</var>

</emu-clause>

<emu-clause id="same-value">
<h1><span class="secnum">3.3</span>SameValue(x, y) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-samevalue">7.2.9</a>)</h1>
<emu-alg><ol><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_46"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>x</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_47"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>y</var>).</li><li>If <emu-xref aoid="Type" id="_ref_48"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid="Type" id="_ref_49"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_50"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Undefined, return <emu-val>true</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_51"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Null, return <emu-val>true</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_52"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is +0 and <var>y</var> is -0, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is -0 and <var>y</var> is +0, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same Number value as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_53"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is String, then<ol><li>If <var>x</var> and <var>y</var> are exactly the same sequence of code units (same length and same code units at corresponding indices) return true; otherwise, return false.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_54"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Boolean, then<ol><li>If <var>x</var> and <var>y</var> are both true or both false, return true; otherwise, return false.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_55"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Symbol, then<ol><li>If <var>x</var> and <var>y</var> are both the same Symbol value, return true; otherwise, return false.</li></ol></li><li><ins>If <emu-xref aoid="Type" id="_ref_56"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is a SIMD type <var>SIMD</var>Type:</ins><ol><li><ins>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1:</ins><ol><li><ins>If <emu-xref aoid="SameValue" id="_ref_57"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<emu-xref aoid="SIMDExtractLane" id="_ref_58"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>x</var>, <var>i</var>), <emu-xref aoid="SIMDExtractLane" id="_ref_59"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>y</var>, <var>i</var>)) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</ins></li></ol></li><li><ins>return <emu-val>true</emu-val></ins></li></ol></li><li>Return <emu-val>true</emu-val> if <var>x</var> and <var>y</var> are the same Object value. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="same-value-zero">
<h1><span class="secnum">3.4</span>SameValueZero(x, y) (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero">7.2.10</a>)</h1>
Add an extra step at the bottom of the definition of <emu-xref aoid="SameValueZero" id="_ref_60"><a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a></emu-xref> for the new case involving the new type:

<emu-alg><ol><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_61"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>x</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_62"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>y</var>).</li><li>If <emu-xref aoid="Type" id="_ref_63"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid="Type" id="_ref_64"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_65"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Undefined, return <emu-val>true</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_66"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Null, return <emu-val>true</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_67"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is +0 and <var>y</var> is -0, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is -0 and <var>y</var> is +0, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is the same Number value as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_68"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is String, then<ol><li>If <var>x</var> and <var>y</var> are exactly the same sequence of code units (same length and same code units at corresponding indices) return true; otherwise, return false.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_69"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Boolean, then<ol><li>If <var>x</var> and <var>y</var> are both true or both false, return true; otherwise, return false.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_70"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Symbol, then<ol><li>If <var>x</var> and <var>y</var> are both the same Symbol value, return true; otherwise, return false.</li></ol></li><li><ins>If <emu-xref aoid="Type" id="_ref_71"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is a SIMD type <var>SIMD</var>Type:</ins><ol><li><ins>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1:</ins><ol><li><ins>If <emu-xref aoid="SameValueZero" id="_ref_72"><a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a></emu-xref>(<emu-xref aoid="SIMDExtractLane" id="_ref_73"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>x</var>, <var>i</var>), <emu-xref aoid="SIMDExtractLane" id="_ref_74"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>y</var>, <var>i</var>)) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</ins></li></ol></li><li><ins>return <emu-val>true</emu-val></ins></li></ol></li><li>Return <emu-val>true</emu-val> if <var>x</var> and <var>y</var> are the same Object value. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="abstract-equality">
<h1><span class="secnum">3.5</span>Abstract Equality Comparison (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison">7.2.12</a>)</h1>
Replace step 10 with the following:

<emu-alg><ol><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_75"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>x</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_76"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>y</var>).</li><li>If <emu-xref aoid="Type" id="_ref_77"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is the same as <emu-xref aoid="Type" id="_ref_78"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>), then<ol><li>Return the result of performing <emu-xref aoid="Strict Equality Comparison" id="_ref_79"><a href="https://tc39.github.io/ecma262/#sec-strict-equality-comparison">Strict Equality Comparison</a></emu-xref> x === y.</li></ol></li><li>If x is null and y is undefined, return <emu-val>true</emu-val>.</li><li>If x is undefined and y is null, return <emu-val>true</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_80"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Number and <emu-xref aoid="Type" id="_ref_81"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>) is String,<br> return the result of the comparison x == <emu-xref aoid="ToNumber" id="_ref_82"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>y</var>).</li><li>If <emu-xref aoid="Type" id="_ref_83"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is String and <emu-xref aoid="Type" id="_ref_84"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>) is Number,<br> return the result of the comparison <emu-xref aoid="ToNumber" id="_ref_85"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>x</var>) == y.</li><li>If <emu-xref aoid="Type" id="_ref_86"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Boolean, return the result of the comparison <emu-xref aoid="ToNumber" id="_ref_87"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>x</var>) == y.</li><li>If <emu-xref aoid="Type" id="_ref_88"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>) is Boolean, return the result of the comparison x == <emu-xref aoid="ToNumber" id="_ref_89"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>y</var>).</li><li>If <emu-xref aoid="Type" id="_ref_90"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is either String, Number, <ins>any <var>SIMD</var>Type,</ins> or Symbol and <emu-xref aoid="Type" id="_ref_91"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>) is Object, then<br>return the result of the comparison x == <emu-xref aoid="ToPrimitive" id="_ref_92"><a href="https://tc39.github.io/ecma262/#sec-toprimitive">ToPrimitive</a></emu-xref>(<var>y</var>).</li><li>If <emu-xref aoid="Type" id="_ref_93"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Object and <emu-xref aoid="Type" id="_ref_94"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>) is either String, Number, <ins>any <var>SIMD</var>Type,</ins> or Symbol, then<br>return the result of the comparison <emu-xref aoid="ToPrimitive" id="_ref_95"><a href="https://tc39.github.io/ecma262/#sec-toprimitive">ToPrimitive</a></emu-xref>(<var>x</var>) == y.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="strict-equality-comparison">
<h1><span class="secnum">3.6</span>Strict Equality Comparison (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison">7.2.13</a>)</h1>
Add a new step 9, before the existing step 9:

<emu-alg><ol><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_96"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>x</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_97"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>y</var>).</li><li>If <emu-xref aoid="Type" id="_ref_98"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid="Type" id="_ref_99"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_100"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Undefined, return <emu-val>true</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_101"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Null, return <emu-val>true</emu-val>.</li><li>If <emu-xref aoid="Type" id="_ref_102"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same Number value as y, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is +0 and y is −0, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is −0 and y is +0, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_103"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is String, then<ol><li>If <var>x</var> and <var>y</var> are exactly the same sequence of code units (same length and same code units at corresponding indices) return true; otherwise, return false.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_104"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Boolean, then<ol><li>If <var>x</var> and <var>y</var> are both true or both false, return true; otherwise, return false.</li></ol></li><li>If <emu-xref aoid="Type" id="_ref_105"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is Symbol, then<ol><li>If <var>x</var> and <var>y</var> are both the same Symbol value, return true; otherwise, return false.</li></ol></li><li><ins>If <emu-xref aoid="Type" id="_ref_106"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>x</var>) is SIMD type <var>SIMD</var>Type:</ins><ol><li><ins>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1:</ins><ol><li><ins>If <emu-xref aoid="SIMDExtractLane" id="_ref_107"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>x</var>, <var>i</var>) === <emu-xref aoid="SIMDExtractLane" id="_ref_108"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>y</var>, <var>i</var>) is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</ins></li></ol></li><li><ins>return <emu-val>true</emu-val></ins></li></ol></li><li>Return <emu-val>true</emu-val> if <var>x</var> and <var>y</var> are the same Object value. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>
</emu-clause>

<emu-clause id="typeof">
<h1><span class="secnum">4</span>The typeof Operator (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator">12.5.6</a>)</h1>
<emu-clause id="typeof-evaluation">
<h1><span class="secnum">4.1</span>Runtime Semantics: Evaluation (<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation">12.5.6.1</a>)</h1>

<emu-table><figure><figcaption>Table 2: typeof Operator results</figcaption>

<table>
<tbody><tr><th>Type of val</th><th>Result</th></tr>
<tr><td><emu-xref aoid="Float32x4" id="_ref_109"><a href="#float32x4">Float32x4</a></emu-xref></td><td>"float32x4"</td></tr>
<tr><td><emu-xref aoid="Int32x4" id="_ref_110"><a href="#int32x4">Int32x4</a></emu-xref></td><td>"int32x4"</td></tr>
<tr><td><emu-xref aoid="Int16x8" id="_ref_111"><a href="#int16x8">Int16x8</a></emu-xref></td><td>"int16x8"</td></tr>
<tr><td><emu-xref aoid="Int8x16" id="_ref_112"><a href="#int8x16">Int8x16</a></emu-xref></td><td>"int8x16"</td></tr>
<tr><td><emu-xref aoid="Uint32x4" id="_ref_113"><a href="#uint32x4">Uint32x4</a></emu-xref></td><td>"uint32x4"</td></tr>
<tr><td><emu-xref aoid="Uint16x8" id="_ref_114"><a href="#uint16x8">Uint16x8</a></emu-xref></td><td>"uint16x8"</td></tr>
<tr><td><emu-xref aoid="Uint8x16" id="_ref_115"><a href="#uint8x16">Uint8x16</a></emu-xref></td><td>"uint8x16"</td></tr>
<tr><td><emu-xref aoid="Bool32x4" id="_ref_116"><a href="#bool32x4">Bool32x4</a></emu-xref></td><td>"bool32x4"</td></tr>
<tr><td><emu-xref aoid="Bool16x8" id="_ref_117"><a href="#bool16x8">Bool16x8</a></emu-xref></td><td>"bool16x8"</td></tr>
<tr><td><emu-xref aoid="Bool8x16" id="_ref_118"><a href="#bool8x16">Bool8x16</a></emu-xref></td><td>"bool8x16"</td></tr>
</tbody></table>
</figure></emu-table>
</emu-clause>
</emu-clause>

<emu-clause id="simd" aoid="%SIMD%">
<h1><span class="secnum">5</span>SIMD</h1>
<p>The <emu-xref aoid="SIMD object" id="_ref_119"><a href="#simd-object-def">SIMD object</a></emu-xref> is the %SIMD% intrinsic object and the initial value of the SIMD property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. The <emu-xref aoid="SIMD object" id="_ref_120"><a href="#simd-object-def">SIMD object</a></emu-xref> is an ordinary object.</p>

<p>The value of the [[Prototype]] internal slot of %SIMD% is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref> (19.1.3).</p>

<emu-clause id="simd-algorithms">
<h1><span class="secnum">5.1</span>Internal algorithms on SIMD types</h1>

<emu-clause id="simd-create" aoid="SIMDCreate">
<h1><span class="secnum">5.1.1</span>SIMDCreate( descriptor, vectorElements )</h1>
<emu-alg><ol><li>Assert: <var>descriptor</var> is a SIMD type descriptor.</li><li>Assert: <var>vectorElements</var> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>Assert: The length of <var>vectorElements</var> = <var>descriptor</var>.[[VectorLength]].</li><li>Let <var>list</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>descriptor</var>.[[VectorLength]].</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>n</var> be <var>descriptor</var>.[[Cast]](<var>vectorElements</var>[<var>i</var>]).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_121"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>n</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>n</var>.</li></ol></li><li>Return the <emu-xref aoid="SIMD value" id="_ref_122"><a href="#simd-value-def">SIMD value</a></emu-xref> specified by the record { [[SIMDTypeDescriptor]]: <var>descriptor</var>, [[SIMDElements]]: <var>list</var> }.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-to-lane" aoid="SIMDToLane">
<h1><span class="secnum">5.1.2</span>SIMDToLane( max, lane )</h1>
<emu-alg><ol><li>Let <var>index</var> be <emu-xref aoid="ToNumber" id="_ref_123"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>lane</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_124"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>index</var>).</li><li>If <emu-xref aoid="SameValueZero" id="_ref_125"><a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a></emu-xref>(<var>index</var>, <emu-xref aoid="ToLength" id="_ref_126"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<var>index</var>)) is <emu-val>false</emu-val> or <var>index</var> &lt; 0 or <var>index</var> ≥ <var>max</var>, throw a RangeError exception.</li><li>Return <var>index</var></li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-abstract-extract-lane" aoid="SIMDExtractLane">
<h1><span class="secnum">5.1.3</span>SIMDExtractLane( value, lane )</h1>
<emu-alg><ol><li>Assert: <emu-xref aoid="Type" id="_ref_127"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>value</var>) is a <var>SIMD</var>Type.</li><li>Let <var>index</var> be <emu-xref aoid="SIMDToLane" id="_ref_128"><a href="#simd-to-lane">SIMDToLane</a></emu-xref>(<var>value</var>.[[SIMDTypeDescriptor]].[[VectorLength]], <var>lane</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_129"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>index</var>).</li><li>Return <var>value</var>.[[SIMDElements]][<var>index</var>]</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-abstract-replace-lane" aoid="SIMDReplaceLane">
<h1><span class="secnum">5.1.4</span>SIMDReplaceLane( value, lane, replacement )</h1>
<emu-alg><ol><li>Assert: <emu-xref aoid="Type" id="_ref_130"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>value</var>) is a <var>SIMD</var>Type.</li><li>Let <var>descriptor</var> be <var>value</var>.[[SIMDTypeDescriptor]].</li><li>Let <var>index</var> be <emu-xref aoid="SIMDToLane" id="_ref_131"><a href="#simd-to-lane">SIMDToLane</a></emu-xref>(<var>descriptor</var>.[[VectorLength]], <var>lane</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_132"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>index</var>).</li><li>Let <var>list</var> be a copy of <var>value</var>.[[SIMDElements]].</li><li>Set <var>list</var>[<var>index</var>] to <var>replacement</var>.</li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_133"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>descriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="maybe-flush-denormal" aoid="MaybeFlushDenormal">
<h1><span class="secnum">5.1.5</span>MaybeFlushDenormal( n, descriptor )</h1>
<p>Two possible internal algorithms are provided. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same choice each time this step is executed.</p>

The first option:

<emu-alg><ol><li>Return <var>n</var>.</li></ol></emu-alg>
The second option:

<emu-alg><ol><li>Let <var>subnormal</var> be false.</li><li>If <var>descriptor</var> is Float32x4Descriptor, and if <var>n</var> rounded (ties to even) to a single-precision floating point number, in the IEEE 754-2008 single precision binary representation, is a subnormal value, let <var>subnormal</var> be true.</li><li>Otherwise, assert <var>descriptor</var> is not a floating point SIMD type descriptor.</li><li>If <var>subnormal</var> is true,<ol><li>If <var>n</var> &gt; 0, return +0.</li><li>Otherwise, return -0.</li></ol></li><li>Otherwise, return <var>n</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-binary" aoid="SIMDBinaryOp">
<h1><span class="secnum">5.1.6</span>SIMDBinaryOp( a, b, op, outputDescriptor )</h1>
<emu-alg><ol><li>Assert: <var>a</var>.[[SIMDTypeDescriptor]] and <var>b</var>.[[SIMDTypeDescriptor]] are the same SIMD type descriptor.</li><li>Let <var>descriptor</var> be <var>a</var>.[[SIMDTypeDescriptor]].</li><li>If <var>outputDescriptor</var> is not provided, let <var>outputDescriptor</var> be <var>descriptor</var>.</li><li>Let <var>list</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>descriptor</var>.[[VectorLength]].</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>ax</var> = <emu-xref aoid="MaybeFlushDenormal" id="_ref_134"><a href="#maybe-flush-denormal">MaybeFlushDenormal</a></emu-xref>(<emu-xref aoid="SIMDExtractLane" id="_ref_135"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>a</var>, <var>i</var>), <var>descriptor</var>).</li><li>Let <var>bx</var> = <emu-xref aoid="MaybeFlushDenormal" id="_ref_136"><a href="#maybe-flush-denormal">MaybeFlushDenormal</a></emu-xref>(<emu-xref aoid="SIMDExtractLane" id="_ref_137"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>b</var>, <var>i</var>), <var>descriptor</var>).</li><li>Let <var>res</var> = op(<var>ax</var>, <var>bx</var>);</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_138"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>res</var>).</li><li>Let <var>res</var> = <emu-xref aoid="MaybeFlushDenormal" id="_ref_139"><a href="#maybe-flush-denormal">MaybeFlushDenormal</a></emu-xref>(<var>res</var>, <var>outputDescriptor</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>res</var>.</li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_140"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>outputDescriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-unary" aoid="SIMDUnaryOp">
<h1><span class="secnum">5.1.7</span>SIMDUnaryOp( a, op [ , flushDenormal ] )</h1>
<emu-alg><ol><li>Let <var>descriptor</var> be <var>a</var>.[[SIMDTypeDescriptor]].</li><li>If <var>flushDenormal</var> is not provided, let <var>flushDenormal</var> be <emu-val>true</emu-val>.</li><li>Let <var>list</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>descriptor</var>.[[VectorLength]].</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_141"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>block</var>).</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>ax</var> = <emu-xref aoid="SIMDExtractLane" id="_ref_142"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>a</var>, <var>i</var>).</li><li>If <var>flushDenormal</var>, let <var>ax</var> be <emu-xref aoid="MaybeFlushDenormal" id="_ref_143"><a href="#maybe-flush-denormal">MaybeFlushDenormal</a></emu-xref>(<var>ax</var>, <var>descriptor</var>).</li><li>Let <var>res</var> = op(<var>ax</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_144"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>res</var>).</li><li>If <var>flushDenormal</var>, let <var>res</var> be <emu-xref aoid="MaybeFlushDenormal" id="_ref_145"><a href="#maybe-flush-denormal">MaybeFlushDenormal</a></emu-xref>(<var>res</var>, <var>descriptor</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>res</var>.</li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_146"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>descriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-scalar" aoid="SIMDScalarOp">
<h1><span class="secnum">5.1.8</span>SIMDScalarOp( a, scalar, op )</h1>
<emu-alg><ol><li>Let <var>descriptor</var> be <var>a</var>.[[SIMDTypeDescriptor]].</li><li>Assert: <var>descriptor</var> is not a floating point SIMD type.</li><li>Let <var>list</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>descriptor</var>.[[VectorLength]].</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_147"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>block</var>).</li><li>For <var>i</var> from 0 to <var>descriptor</var>.[[VectorLength]],<ol><li>Let <var>ax</var> = <emu-xref aoid="SIMDExtractLane" id="_ref_148"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>a</var>, <var>i</var>).</li><li>Let <var>res</var> = op(<var>ax</var>, <var>scalar</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_149"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>res</var>).</li><li>Set <var>list</var>[<var>i</var>] to <var>res</var>.</li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_150"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>descriptor</var>, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load" aoid="SIMDLoad">
<h1><span class="secnum">5.1.9</span>SIMDLoad( dataBlock, descriptor, byteOffset [, length] )</h1>
<emu-alg><ol><li>Assert: <var>dataBlock</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>, <var>descriptor</var> is a SIMD type descriptor</li><li>If <var>length</var> is not provided, let <var>length</var> be <var>descriptor</var>.[[VectorLength]]. Otherwise, assert <var>length</var> ≤ <var>descriptor</var>.[[VectorLength]].</li><li>Assert: <var>byteOffset</var> is an integer greater than or equal to zero, and less than or equal to the size of <var>dataBlock</var> - <var>descriptor</var>.[[ElementSize]] × <var>length</var>.</li><li>Let <var>list</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>descriptor</var>.[[VectorLength]], initialized to all 0.</li><li>For <var>i</var> from 0 to <var>length</var> - 1,<ol><li>Set <var>list</var>[<var>i</var>] to <var>descriptor</var>.[[DeserializeElement]](<var>dataBlock</var>, <var>byteOffset</var> + <var>i</var> × <var>descriptor</var>.[[ElementSize]]).</li></ol></li><li>Return the record { [[SIMDTypeDescriptor]]: <var>descriptor</var>, [[SIMDElements]]: <var>list</var> }.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load-from-tarray" aoid="SIMDLoadFromTypedArray">
<h1><span class="secnum">5.1.10</span>SIMDLoadFromTypedArray( tarray, index, descriptor [, length] )</h1>
<emu-alg><ol><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a TypeError exception.</li><li>If <var>length</var> is not provided, let <var>length</var> be <var>descriptor</var>.[[VectorLength]]. Otherwise, assert <var>length</var> ≤ <var>descriptor</var>.[[VectorLength]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_151"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>tarray</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, throw a TypeError exception.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <emu-xref aoid="ToLength" id="_ref_152"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<var>index</var>), throw a TypeError exception.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ <var>tarray</var>.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>descriptor</var>.[[ElementSize]] × length &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError exception.</li><li>Return <emu-xref aoid="SIMDLoad" id="_ref_153"><a href="#simd-load">SIMDLoad</a></emu-xref>(<var>block</var>, <var>descriptor</var>, <var>byteIndex</var>, length).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store" aoid="SIMDStore">
<h1><span class="secnum">5.1.11</span>SIMDStore( dataBlock, descriptor, byteOffset, n [, length] )</h1>
<emu-alg><ol><li>Assert: <var>dataBlock</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>, <var>descriptor</var> is a SIMD type descriptor</li><li>If <var>length</var> is not provided, let <var>length</var> be <var>descriptor</var>.[[VectorLength]]. Otherwise, assert <var>length</var> ≤ <var>descriptor</var>.[[VectorLength]].</li><li>Assert: <var>byteOffset</var> is an integer greater than or equal to zero, and less than or equal to the size of <var>dataBlock</var> - <var>descriptor</var>.[[ElementSize]] × <var>length</var>.</li><li>For <var>i</var> from 0 to <var>length</var> - 1,<ol><li><var>descriptor</var>.[[SerializeElement]](<var>dataBlock</var>, <var>byteOffset</var> + <var>i</var> × <var>descriptor</var>.[[ElementSize]], <var>n</var>.[[SIMDElements]][<var>i</var>]).</li></ol></li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store-in-tarray" aoid="SIMDStoreInTypedArray">
<h1><span class="secnum">5.1.12</span>SIMDStoreInTypedArray( tarray, index, descriptor, n [, length] )</h1>
<emu-alg><ol><li>If <var>n</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>If <var>length</var> is not provided, let <var>length</var> be <var>descriptor</var>.[[VectorLength]]. Otherwise, assert <var>length</var> ≤ <var>descriptor</var>.[[VectorLength]].</li><li>If <emu-xref aoid="IsDetachedBuffer" id="_ref_154"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>tarray</var>.[[ViewedArrayBuffer]]) is <emu-val>true</emu-val>, throw a TypeError exception.</li><li>If <var>tarray</var> does not have a [[ViewedArrayBuffer]] field, throw a TypeError exception.</li><li>Let <var>block</var> be <var>tarray</var>.[[ViewedArrayBuffer]].[[ArrayBufferData]]</li><li>If <var>index</var> ≠ <emu-xref aoid="ToLength" id="_ref_155"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<var>index</var>), throw a TypeError exception.</li><li>Let <var>elementLength</var> be <var>tarray</var>.[[ByteLength]] ÷ _tarray.[[ArrayLength]].</li><li>Let <var>byteIndex</var> be <var>index</var> × <var>elementLength</var>.</li><li>If <var>byteIndex</var> + <var>SIMD</var>Descriptor.[[ElementSize]] × <var>length</var> &gt; <var>tarray</var>.[[ByteLength]] or <var>byteIndex</var> &lt; 0, throw a RangeError exception.</li><li><emu-xref aoid="SIMDStore" id="_ref_156"><a href="#simd-store">SIMDStore</a></emu-xref>(<var>block</var>, <var>SIMD</var>Descriptor, <var>byteIndex</var>, <var>simd</var>, <var>length</var>).</li><li>Return <var>n</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-reinterpret-cast" aoid="SIMDReinterpretCast">
<h1><span class="secnum">5.1.13</span>SIMDReinterpretCast( value, newDescriptor )</h1>
<emu-note><span class="note">Note</span><div class="note-contents">This is used to define operations like SIMD.Float32x4.fromInt8x16Bits.</div></emu-note>
<emu-alg><ol><li>Assert: <var>value</var>.[[SIMDTypeDescriptor]].[[VectorLength]] × <var>value</var>.[[SIMDTypeDescriptor]].[[ElementSize]] = <var>newDescriptor</var>.[[VectorLength]] × <var>newDescriptor</var>.[[ElementSize]].</li><li>Let <var>bytes</var> be <var>newDescriptor</var>.[[VectorLength]] × <var>newDescriptor</var>.[[ElementSize]].</li><li>Let <var>block</var> be the result of <emu-xref aoid="CreateByteDataBlock" id="_ref_157"><a href="https://tc39.github.io/ecma262/#sec-createbytedatablock">CreateByteDataBlock</a></emu-xref>(<var>bytes</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_158"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>block</var>).</li><li><emu-xref aoid="SIMDStore" id="_ref_159"><a href="#simd-store">SIMDStore</a></emu-xref>(<var>block</var>, <var>value</var>, 0).</li><li>Return <emu-xref aoid="SIMDLoad" id="_ref_160"><a href="#simd-load">SIMDLoad</a></emu-xref>(<var>block</var>, <var>newDescriptor</var>, 0).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-int-type" aoid="SIMDBoolType">
<h1><span class="secnum">5.1.14</span>SIMDBoolType( descriptor )</h1>
<emu-alg><ol><li>Assert: <var>descriptor</var>.[[VectorLength]] × <var>descriptor</var>.[[ElementSize]] = 128. Otherwise, in a future extension to the spec, different boolean descriptors will be returned.</li><li>Let <var>length</var> be <var>descriptor</var>.[[VectorLength]].</li><li>If <var>length</var> = 4, return Bool32x4Descriptor.</li><li>If <var>length</var> = 8, return Bool16x8Descriptor.</li><li>Assert <var>length</var> = 16.</li><li>Return Bool8x16Descriptor.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-relational-op" aoid="SIMDRelationalOp">
<h1><span class="secnum">5.1.15</span>SIMDRelationalOp( a, b, op )</h1>
<emu-alg><ol><li>Let <var>outputDescriptor</var> be <emu-xref aoid="SIMDBoolType" id="_ref_161"><a href="#simd-int-type">SIMDBoolType</a></emu-xref>(<var>a</var>.[[SIMDTypeDescriptor]]).</li><li>Return <emu-xref aoid="SIMDBinaryOp" id="_ref_162"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <var>op</var>, <var>outputDescriptor</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="abs" aoid="MathAbs">
<h1><span class="secnum">5.1.16</span>MathAbs( x )</h1>
Returns the absolute value of x; the result has the same magnitude as x but has positive sign.

<ul>
<li>If x is NaN, the result is NaN.</li>
<li>If x is −0, the result is +0.</li>
<li>If x is −∞, the result is +∞.</li>
</ul>
</emu-clause>

<emu-clause id="fround" aoid="ToFloat32">
<h1><span class="secnum">5.1.17</span>ToFloat32( argument )</h1>
<emu-alg><ol><li>Let x be <emu-xref aoid="ToNumber" id="_ref_163"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(argument).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_164"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(x).</li><li>If x is NaN, return NaN.</li><li>If x is one of +0, −0, +∞, −∞, return x.</li><li>Let x32 be the result of converting x to a value in IEEE 754-2008 binary32 format using roundTiesToEven.</li><li>Let x64 be the result of converting x32 to a value in IEEE 754-2008 binary64 format.</li><li>Return the ECMAScript Number value corresponding to x64.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="abs" aoid="MathSqrt">
<h1><span class="secnum">5.1.18</span>MathSqrt( x )</h1>
Returns an implementation-dependent approximation to the square root of x.

<ul>
<li>If <var>x</var> is NaN, the result is NaN.</li>
<li>If <var>x</var> is less than 0, the result is NaN.</li>
<li>If <var>x</var> is +0, the result is +0.</li>
<li>If <var>x</var> is −0, the result is −0.</li>
<li>If <var>x</var> is +∞, the result is +∞.</li>
</ul>
</emu-clause>

<emu-clause id="imul" aoid="MathImul">
<h1><span class="secnum">5.1.19</span>MathImul(n, m)</h1>
<emu-alg><ol><li>Let <var>a</var> be <emu-xref aoid="ToUint32" id="_ref_165"><a href="https://tc39.github.io/ecma262/#sec-touint32">ToUint32</a></emu-xref>(<var>n</var>).</li><li>Let <var>b</var> be <emu-xref aoid="ToUint32" id="_ref_166"><a href="https://tc39.github.io/ecma262/#sec-touint32">ToUint32</a></emu-xref>(<var>m</var>).</li><li>Let <var>product</var> be (<var>a</var> × b) <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> 2<sup>32</sup>.</li><li>If <var>product</var> ≥ 2<sup>31</sup>, return <var>product</var> − 2<sup>32</sup>, otherwise return <var>product</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="min" aoid="MathMin">
<h1><span class="secnum">5.1.20</span>MathMin(n, m)</h1>
Given two arguments, calls <emu-xref aoid="ToNumber" id="_ref_167"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref> on each of the arguments and returns the smaller of the resulting values.

<ul>
<li>If <var>n</var> or <var>m</var> is is NaN, the result is NaN.</li>
<li>The comparison of values to determine the smallest value is done using the <emu-xref aoid="Abstract Relational Comparison" id="_ref_168"><a href="https://tc39.github.io/ecma262/#sec-abstract-relational-comparison">Abstract Relational Comparison</a></emu-xref> algorithm (7.2.11) except that +0 is considered to be larger than −0.</li>
</ul>
</emu-clause>

<emu-clause id="max-num" aoid="MaxNum">
<h1><span class="secnum">5.1.21</span>MaxNum(n, m)</h1>
<emu-alg><ol><li>Assert <emu-xref aoid="Type" id="_ref_169"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>n</var>) is Number and <emu-xref aoid="Type" id="_ref_170"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>m</var>) is Number.</li><li>If <var>n</var> is <emu-val>NaN</emu-val>, return <var>m</var>.</li><li>If <var>m</var> is <emu-val>NaN</emu-val>, return <var>n</var>.</li><li>Let <var>result</var> be MathMax(<var>n</var>, <var>m</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_171"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="min-num" aoid="MinNum">
<h1><span class="secnum">5.1.22</span>MinNum(n, m)</h1>
<emu-alg><ol><li>Assert <emu-xref aoid="Type" id="_ref_172"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>n</var>) is Number and <emu-xref aoid="Type" id="_ref_173"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>m</var>) is Number.</li><li>If <var>n</var> is <emu-val>NaN</emu-val>, return <var>m</var>.</li><li>If <var>m</var> is <emu-val>NaN</emu-val>, return <var>n</var>.</li><li>Let <var>result</var> be <emu-xref aoid="MathMin" id="_ref_174"><a href="#min">MathMin</a></emu-xref>(<var>n</var>, <var>m</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_175"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="reciprocal" aoid="ReciprocalApproximation">
<h1><span class="secnum">5.1.23</span>ReciprocalApproximation(n)</h1>
Returns an implementation-dependent approximation to the reciprocal of <var>n</var>.

<ul>
<li>If <var>n</var> is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.</li>
<li>If <var>n</var> is +0, the result is +∞.</li>
<li>If <var>n</var> is -0, the result is -∞.</li>
<li>If <var>n</var> is +∞, the result is +0.</li>
<li>If <var>n</var> is -∞, the result is -0.</li>
</ul>
</emu-clause>

<emu-clause id="reciprocal" aoid="ReciprocalSqrtApproximation">
<h1><span class="secnum">5.1.24</span>ReciprocalSqrtApproximation(n)</h1>
Returns an implementation-dependent approximation to the reciprocal of the square root of <var>n</var>.

<ul>
<li>If <var>n</var> is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.</li>
<li>If <var>n</var> is +0, the result is +∞.</li>
<li>If <var>n</var> is -0, the result is -∞.</li>
<li>If <var>n</var> is +∞, the result is +0.</li>
<li>If <var>n</var> is less than 0, the result is <emu-val>NaN</emu-val>.</li>
</ul>
</emu-clause>

<emu-clause id="saturate" aoid="Saturate">
<h1><span class="secnum">5.1.25</span>Saturate( descriptor, x )</h1>
<emu-alg><ol><li>If <var>x</var> &gt; <var>descriptor</var>.[[ElementMax]], return <var>descriptor</var>.[[ElementMax]].</li><li>Otherwise, if <var>x</var> &lt; <var>descriptor</var>.[[ElementMin]], return <var>descriptor</var>.[[ElementMin]]</li><li>Return <var>x</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="add-saturate" aoid="AddSaturate">
<h1><span class="secnum">5.1.26</span>AddSaturate( descriptor )( x, y )</h1>
<emu-alg><ol><li>Return <emu-xref aoid="Saturate" id="_ref_176"><a href="#saturate">Saturate</a></emu-xref>(<var>descriptor</var>, <var>x</var> + <var>y</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="sub-saturate" aoid="SubSaturate">
<h1><span class="secnum">5.1.27</span>SubSaturate( descriptor )( x, y )</h1>
<emu-alg><ol><li>Return <emu-xref aoid="Saturate" id="_ref_177"><a href="#saturate">Saturate</a></emu-xref>(<var>descriptor</var>, <var>x</var> - <var>y</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="bitwise-op" aoid="BitwiseOp">
<h1><span class="secnum">5.1.28</span>BitwiseOp( @ )( lval, rval )</h1>
<emu-alg><ol><li>Let <var>lnum</var> be <emu-xref aoid="ToInt32" id="_ref_178"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>lval</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_179"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>lnum</var>).</li><li>Let rnum be <emu-xref aoid="ToInt32" id="_ref_180"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>rval</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_181"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>rnum</var>).</li><li>Return the result of applying the bitwise operator @ to <var>lnum</var> and <var>rnum</var>. The result is a signed 32 bit integer.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="array-join" aoid="ArrayJoin">
<h1><span class="secnum">5.1.29</span>ArrayJoin( array, separator )</h1>
<emu-alg><ol><li>Let <var>O</var> be <emu-xref aoid="ToObject" id="_ref_182"><a href="https://tc39.github.io/ecma262/#sec-toobject">ToObject</a></emu-xref>(<var>array</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_183"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>O</var>).</li><li>Let len be <emu-xref aoid="ToLength" id="_ref_184"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<emu-xref aoid="Get" id="_ref_185"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref>(<var>O</var>, "length")).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_186"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>len</var>).</li><li>If <var>separator</var> is undefined, let <var>separator</var> be the single-element String ",".</li><li>Let <var>sep</var> be <emu-xref aoid="ToString" id="_ref_187"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>(<var>separator</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_188"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>sep</var>).</li><li>If <var>len</var> is zero, return the empty String.</li><li>Let <var>element0</var> be <emu-xref aoid="Get" id="_ref_189"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref>(<var>O</var>, "0").</li><li>If <var>element0</var> is undefined or null, let <var>R</var> be the empty String; otherwise, let R be <emu-xref aoid="ToString" id="_ref_190"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>(<var>element0</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_191"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>R</var>).</li><li>Let <var>k</var> be 1.</li><li>Repeat, while <var>k</var> &lt; <var>len</var><ol><li>Let <var>S</var> be the String value produced by concatenating <var>R</var> and <var>sep</var>.</li><li>Let <var>element</var> be <emu-xref aoid="Get" id="_ref_192"><a href="https://tc39.github.io/ecma262/#sec-get-o-p">Get</a></emu-xref>(<var>O</var>, <emu-xref aoid="ToString" id="_ref_193"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>(<var>k</var>)).</li><li>If <var>element</var> is undefined or null, let <var>next</var> be the empty String; otherwise, let <var>next</var> be <emu-xref aoid="ToString" id="_ref_194"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>(<var>element</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_195"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>Let <var>R</var> be a String value produced by concatenating <var>S</var> and <var>next</var>.</li><li>Increase <var>k</var> by 1.</li></ol></li><li>Return <var>R</var>.</li></ol></emu-alg>
</emu-clause>

</emu-clause>

<emu-clause id="simd-constructor">
<h1><span class="secnum">5.2</span>Constructor properties <var>SIMD</var>Constructor of the SIMD object</h1>
<p>Each <var>SIMD</var>Constructor, namely <emu-xref aoid="Float32x4" id="_ref_196"><a href="#float32x4">Float32x4</a></emu-xref>, <emu-xref aoid="Int32x4" id="_ref_197"><a href="#int32x4">Int32x4</a></emu-xref>, <emu-xref aoid="Int16x8" id="_ref_198"><a href="#int16x8">Int16x8</a></emu-xref>, <emu-xref aoid="Int8x16" id="_ref_199"><a href="#int8x16">Int8x16</a></emu-xref>, <emu-xref aoid="Uint32x4" id="_ref_200"><a href="#uint32x4">Uint32x4</a></emu-xref>, <emu-xref aoid="Uint16x8" id="_ref_201"><a href="#uint16x8">Uint16x8</a></emu-xref>, <emu-xref aoid="Uint8x16" id="_ref_202"><a href="#uint8x16">Uint8x16</a></emu-xref>, <emu-xref aoid="Bool32x4" id="_ref_203"><a href="#bool32x4">Bool32x4</a></emu-xref>, <emu-xref aoid="Bool16x8" id="_ref_204"><a href="#bool16x8">Bool16x8</a></emu-xref>, and <emu-xref aoid="Bool8x16" id="_ref_205"><a href="#bool8x16">Bool8x16</a></emu-xref>, is associated with a <var>SIMD</var>Type and <var>SIMD</var>Descriptor. This section describes the constructors and properties on them. Most properties are identical, existing separately defined on each constructor, with most differences being in the <var>SIMD</var>Descriptor. Certain functions are defined only on a subset of <var>SIMD</var>Constructors, however, and this is noted above their algorithm definition.</p>

<p>Each SIMD constructor is defined as a property of the <emu-xref aoid="SIMD object" id="_ref_206"><a href="#simd-object-def">SIMD object</a></emu-xref>. For example, the constructor for <emu-xref aoid="Float32x4" id="_ref_207"><a href="#float32x4">Float32x4</a></emu-xref> is defined as the property <code>SIMD.Float32x4</code>.</p>

The definitions of the constructor and properties of the constructor to follow constitute different identities of functions and objects for each of the copies; in a real implementation, they may call out to completely different pieces of code, even if their implementation in the spec is the same.

<emu-clause id="simd-wrapper">
<h1><span class="secnum">5.2.1</span><var>SIMD</var>Constructor( ...values )</h1>
<emu-note><span class="note">Note</span><div class="note-contents">SIMD wrapped objects cannot be created using <code>new</code> on <var>SIMD</var>Constructor; they can be created explicitly with <code>Object()</code> however.</div></emu-note>
<emu-alg><ol><li>If <emu-val>NewTarget</emu-val> is not undefined, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fields</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>For integer <var>n</var> from <emu-val>0</emu-val> to <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Append <var>values</var>[<var>n</var>] to the end of <var>fields</var>, or <emu-val>undefined</emu-val> if there were not enough arguments.</li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_208"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>SIMD</var>Descriptor, <var>fields</var>).</li></ol></emu-alg>
The <code>length</code> property of <code>_SIMD_Constructor</code> is <var>SIMD</var>Descriptor.[[VectorLength]].

</emu-clause>
</emu-clause>

<emu-clause id="constructor-properties">
<h1><span class="secnum">5.3</span>Properties of the <var>SIMD</var>Constructor constructors</h1>

<p>The value of the [[Prototype]] internal slot of <var>SIMD</var>Constructor is the intrinsic object <emu-xref href="#sec-properties-of-the-function-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-function-prototype-object">%FunctionPrototype%</a></emu-xref> (19.2.3).</p>

<p>The <code>length</code> property of <var>SIMD</var>Constructor is <var>SIMD</var>Descriptor.[[VectorLength]].</p>

Each <var>SIMD</var>Constructor has the following properties:

<emu-clause id="simd-splat">
<h1><span class="secnum">5.3.1</span><var>SIMD</var>Constructor.splat(n)</h1>
<emu-alg><ol><li>Let <var>list</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>SIMD</var>Descriptor.[[VectorLength]], with all entries filled with <var>n</var>.</li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_209"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-check">
<h1><span class="secnum">5.3.2</span><var>SIMD</var>Constructor.check(a)</h1>
<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <var>a</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-add">
<h1><span class="secnum">5.3.3</span><var>SIMD</var>Constructor.add(a, b)</h1>
<p>This definition uses <code>+</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-addition-operator-plus">ES2015 12.7.3 (The Addition operator ( + ))</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_210"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>+</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_211"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">On <code>Float32x4</code>, in this specification, the math is done on two 64-bit values which have a precise representation as a 32-bit float, and then rounded to a Float32. This is equivalent to doing the math on two 32-bit values and storing the result in a 32-bit float. For more information, see  <a href="http://dl.acm.org/citation.cfm?id=221334">When is Double Rounding Innocuous?</a>.</div></emu-note>
</emu-clause>

<emu-clause id="simd-sub">
<h1><span class="secnum">5.3.4</span><var>SIMD</var>Constructor.sub(a, b)</h1>
<p>This definition uses <code>-</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-subtraction-operator-minus">ES2015 12.7.4 (The Subtraction operator ( - ))</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_212"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>-</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_213"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">On <code>Float32x4</code>, in this specification, the math is done on two 64-bit values which have a precise representation as a 32-bit float, and then rounded to a Float32. This is equivalent to doing the math on two 32-bit values and storing the result in a 32-bit float. For more information, see  <a href="http://dl.acm.org/citation.cfm?id=221334">When is Double Rounding Innocuous?</a>.</div></emu-note>
</emu-clause>

<emu-clause id="simd-mul">
<h1><span class="secnum">5.3.5</span><var>SIMD</var>Constructor.mul(a, b)</h1>
<p>This definition uses <code>*</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-mul-operator">ES2015 12.6.3.1 (Applying the * Operator)</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>If <var>SIMD</var>Type is an integer SIMD type, let <var>op</var> be <emu-xref aoid="MathImul" id="_ref_214"><a href="#imul">MathImul</a></emu-xref>; otherwise, <var>SIMD</var>Type is a floating point SIMD type, and let <var>op</var> be <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-mul-operator"><code>*</code></a>.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_215"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <var>op</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_216"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">On <code>Float32x4</code>, in this specification, the math is done on two 64-bit values which have a precise representation as a 32-bit float, and then rounded to a Float32. This is equivalent to doing the math on two 32-bit values and storing the result in a 32-bit float. For more information, see  <a href="http://dl.acm.org/citation.cfm?id=221334">When is Double Rounding Innocuous?</a>.</div></emu-note>
</emu-clause>

<emu-clause id="simd-div">
<h1><span class="secnum">5.3.6</span><var>SIMD</var>Constructor.div(a, b)</h1>
<p>This definition uses <code>/</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-div-operator">ES2015 12.6.3.2 (Applying the / Operator)</a>.</p>

This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_217"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-applying-the-div-operator"><code>/</code></a>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_218"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">On <code>Float32x4</code>, in this specification, the math is done on two 64-bit values which have a precise representation as a 32-bit float, and then rounded to a Float32. This is equivalent to doing the math on two 32-bit values and storing the result in a 32-bit float. For more information, see  <a href="http://dl.acm.org/citation.cfm?id=221334">When is Double Rounding Innocuous?</a>.</div></emu-note>
</emu-clause>

<emu-clause id="simd-max">
<h1><span class="secnum">5.3.7</span><var>SIMD</var>Constructor.max(a, b)</h1>
This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_219"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, MathMax).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_220"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-min">
<h1><span class="secnum">5.3.8</span><var>SIMD</var>Constructor.min(a, b)</h1>
This property is defined only on floating point SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_221"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="MathMin" id="_ref_222"><a href="#min">MathMin</a></emu-xref>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_223"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-max-num">
<h1><span class="secnum">5.3.9</span><var>SIMD</var>Constructor.maxNum(a, b)</h1>
This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_224"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="MaxNum" id="_ref_225"><a href="#max-num">MaxNum</a></emu-xref>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_226"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-min-num">
<h1><span class="secnum">5.3.10</span><var>SIMD</var>Constructor.minNum(a, b)</h1>
This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_227"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="MinNum" id="_ref_228"><a href="#min-num">MinNum</a></emu-xref>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_229"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-neg">
<h1><span class="secnum">5.3.11</span><var>SIMD</var>Constructor.neg(a)</h1>
<p>This definition uses unary <code>-</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-unary-minus-operator">ES2015 12.5.10 (Unary - Operator)</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDUnaryOp" id="_ref_230"><a href="#simd-unary">SIMDUnaryOp</a></emu-xref>(<var>a</var>, <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-unary-minus-operator"><code>-</code></a>, <emu-val>false</emu-val>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_231"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-sqrt">
<h1><span class="secnum">5.3.12</span><var>SIMD</var>Constructor.sqrt(a)</h1>
This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDUnaryOp" id="_ref_232"><a href="#simd-unary">SIMDUnaryOp</a></emu-xref>(<var>a</var>, <emu-xref aoid="MathSqrt" id="_ref_233"><a href="#abs">MathSqrt</a></emu-xref>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_234"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-reciprocal-approximation">
<h1><span class="secnum">5.3.13</span><var>SIMD</var>Constructor.reciprocalApproximation(a)</h1>
This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDUnaryOp" id="_ref_235"><a href="#simd-unary">SIMDUnaryOp</a></emu-xref>(<var>a</var>, <emu-xref aoid="ReciprocalApproximation" id="_ref_236"><a href="#reciprocal">ReciprocalApproximation</a></emu-xref>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_237"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-reciprocal-sqrt-approximation">
<h1><span class="secnum">5.3.14</span><var>SIMD</var>Constructor.reciprocalSqrtApproximation(a)</h1>
This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDUnaryOp" id="_ref_238"><a href="#simd-unary">SIMDUnaryOp</a></emu-xref>(<var>a</var>, <emu-xref aoid="ReciprocalSqrtApproximation" id="_ref_239"><a href="#reciprocal">ReciprocalSqrtApproximation</a></emu-xref>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_240"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-abs">
<h1><span class="secnum">5.3.15</span><var>SIMD</var>Constructor.abs(a)</h1>
This operation is only defined on  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDUnaryOp" id="_ref_241"><a href="#simd-unary">SIMDUnaryOp</a></emu-xref>(<var>a</var>, <emu-xref aoid="MathAbs" id="_ref_242"><a href="#abs">MathAbs</a></emu-xref>, <emu-val>false</emu-val>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_243"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-and">
<h1><span class="secnum">5.3.16</span><var>SIMD</var>Constructor.and(a, b)</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-boolean-type">boolean</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_244"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="BitwiseOp" id="_ref_245"><a href="#bitwise-op">BitwiseOp</a></emu-xref>(&amp;)).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_246"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-xor">
<h1><span class="secnum">5.3.17</span><var>SIMD</var>Constructor.xor(a, b)</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-boolean-type">boolean</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_247"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="BitwiseOp" id="_ref_248"><a href="#bitwise-op">BitwiseOp</a></emu-xref>(^)).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_249"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-or">
<h1><span class="secnum">5.3.18</span><var>SIMD</var>Constructor.or(a, b)</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-boolean-type">boolean</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_250"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="BitwiseOp" id="_ref_251"><a href="#bitwise-op">BitwiseOp</a></emu-xref>(|)).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_252"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-not">
<h1><span class="secnum">5.3.19</span><var>SIMD</var>Constructor.not(a)</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-boolean-type">boolean</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDUnaryOp" id="_ref_253"><a href="#simd-unary">SIMDUnaryOp</a></emu-xref>(<var>a</var>, <code>~</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_254"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-less-than">
<h1><span class="secnum">5.3.20</span><var>SIMD</var>Constructor.lessThan(a, b)</h1>
<p>This definition uses <code>&lt;</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDRelationalOp" id="_ref_255"><a href="#simd-relational-op">SIMDRelationalOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>&lt;</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_256"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">Due to the definition of <emu-xref aoid="SIMDRelationalOp" id="_ref_257"><a href="#simd-relational-op">SIMDRelationalOp</a></emu-xref>, denormals will perform in this function as if they are equal to each other on some platforms, but not others.</div></emu-note>
</emu-clause>

<emu-clause id="simd-less-than-or-equal">
<h1><span class="secnum">5.3.21</span><var>SIMD</var>Constructor.lessThanOrEqual(a, b)</h1>
<p>This definition uses <code>&lt;=</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDRelationalOp" id="_ref_258"><a href="#simd-relational-op">SIMDRelationalOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>&lt;=</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_259"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-greater-than">
<h1><span class="secnum">5.3.22</span><var>SIMD</var>Constructor.greaterThan(a, b)</h1>
<p>This definition uses <code>&gt;</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDRelationalOp" id="_ref_260"><a href="#simd-relational-op">SIMDRelationalOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>&gt;</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_261"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-greater-than-or-equal">
<h1><span class="secnum">5.3.23</span><var>SIMD</var>Constructor.greaterThanOrEqual(a, b)</h1>
<p>This definition uses <code>&gt;=</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDRelationalOp" id="_ref_262"><a href="#simd-relational-op">SIMDRelationalOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>&gt;=</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_263"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-equal">
<h1><span class="secnum">5.3.24</span><var>SIMD</var>Constructor.equal(a, b)</h1>
<p>This definition uses <code>===</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison">ES2015 7.2.13 (Strict Equality Comparison)</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDRelationalOp" id="_ref_264"><a href="#simd-relational-op">SIMDRelationalOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>===</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_265"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">The resulting notion of equality is weaker than <code>===</code> on some platforms because denormals may be flushed to 0.</div></emu-note>
</emu-clause>

<emu-clause id="simd-not-equal">
<h1><span class="secnum">5.3.25</span><var>SIMD</var>Constructor.notEqual(a, b)</h1>
<p>This definition uses <code>!==</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison">ES2015 7.2.13 (Strict Equality Comparison)</a>.</p>

This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDRelationalOp" id="_ref_266"><a href="#simd-relational-op">SIMDRelationalOp</a></emu-xref>(<var>a</var>, <var>b</var>, <code>!==</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_267"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">The resulting notion of equality is weaker than === on some platforms because denormals may be flushed to 0.</div></emu-note>
</emu-clause>

<emu-clause id="simd-any-true">
<h1><span class="secnum">5.3.26</span><var>SIMD</var>Constructor.anyTrue(a)</h1>
This operation is only defined on  <a href="#simd-boolean-type">boolean</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>If <var>a</var>.[[SIMDElements]][<var>i</var>] is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li></ol></li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-all-true">
<h1><span class="secnum">5.3.27</span><var>SIMD</var>Constructor.allTrue(a)</h1>
This operation is only defined on  <a href="#simd-boolean-type">boolean</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>If <var>a</var>.[[SIMDElements]][<var>i</var>] is <emu-val>false</emu-val>, return <emu-val>false</emu-val>.</li></ol></li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-select">
<h1><span class="secnum">5.3.28</span><var>SIMD</var>Constructor.select( selector, a, b )</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>outputDescriptor</var> be <emu-xref aoid="SIMDBoolType" id="_ref_268"><a href="#simd-int-type">SIMDBoolType</a></emu-xref>(<var>SIMD</var>Descriptor).</li><li>If <var>selector</var>.[[SIMDTypeDescriptor]] is not <var>outputDescriptor</var>, throw a TypeError exception.</li><li>Let <var>list</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>For <var>i</var> from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>If <var>sector</var>.[[SIMDElements]][<var>i</var>] is <emu-val>true</emu-val>, let <var>list</var>[<var>i</var>] be <var>a</var>.[[SIMDElements]][<var>i</var>].</li><li>Otherwise, let <var>list</var>[<var>i</var>] be <var>b</var>.[[SIMDElements]][<var>i</var>].</li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_269"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-add-saturate">
<h1><span class="secnum">5.3.29</span><var>SIMD</var>Constructor.addSaturate( a, b )</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> SIMD types whose <var>SIMD</var>Descriptor.[[ElementSize]] ≤ 2.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_270"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="AddSaturate" id="_ref_271"><a href="#add-saturate">AddSaturate</a></emu-xref>(<var>a</var>.[[SIMDTypeDescriptor]])).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_272"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">This operation is not defined on <emu-xref aoid="Uint32x4" id="_ref_273"><a href="#uint32x4">Uint32x4</a></emu-xref> and <emu-xref aoid="Int32x4" id="_ref_274"><a href="#int32x4">Int32x4</a></emu-xref> because it is not accelerated by current hardware on those types.</div></emu-note>
</emu-clause>

<emu-clause id="simd-sub-saturate">
<h1><span class="secnum">5.3.30</span><var>SIMD</var>Constructor.subSaturate( a, b )</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> SIMD types whose <var>SIMD</var>Descriptor.[[ElementSize]] ≤ 2.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor or <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>result</var> be <emu-xref aoid="SIMDBinaryOp" id="_ref_275"><a href="#simd-binary">SIMDBinaryOp</a></emu-xref>(<var>a</var>, <var>b</var>, <emu-xref aoid="SubSaturate" id="_ref_276"><a href="#sub-saturate">SubSaturate</a></emu-xref>(<var>a</var>.[[SIMDTypeDescriptor]])).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_277"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">This operation is not defined on <emu-xref aoid="Uint32x4" id="_ref_278"><a href="#uint32x4">Uint32x4</a></emu-xref> and <emu-xref aoid="Int32x4" id="_ref_279"><a href="#int32x4">Int32x4</a></emu-xref> because it is not accelerated by current hardware on those types.</div></emu-note>
</emu-clause>

<emu-clause id="simd-shift-left-by-scalar">
<h1><span class="secnum">5.3.31</span><var>SIMD</var>Constructor.shiftLeftByScalar( a, bits )</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> SIMD types. This definition uses <code>&lt;&lt;</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-left-shift-operator">ES2015 12.8.3 (The Left Shift Operator ( &lt;&lt; ))</a>.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>scalar</var> be <emu-xref aoid="ToUint32" id="_ref_280"><a href="https://tc39.github.io/ecma262/#sec-touint32">ToUint32</a></emu-xref>(<var>bits</var>).</li><li>Let <var>shiftCount</var> be <var>scalar</var> <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> (<var>SIMD</var>Descriptor.[[ElementSize]] × 8)</li><li>Let <var>result</var> be <emu-xref aoid="SIMDScalarOp" id="_ref_281"><a href="#simd-scalar">SIMDScalarOp</a></emu-xref>(<var>a</var>, <var>shiftCount</var>, <code>&lt;&lt;</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_282"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">The "masked" shift count semantics matches the ECMAScript scalar shift semantics.</div></emu-note>
</emu-clause>

<emu-clause id="simd-shift-right-by-scalar">
<h1><span class="secnum">5.3.32</span><var>SIMD</var>Constructor.shiftRightByScalar( a, bits )</h1>
This operation is only defined on  <a href="#simd-integer-type">integer</a> SIMD types. On  <a href="#simd-unsigned-integer-type">unsigned</a> SIMD types, the following definition is used. This definition uses <code>&gt;&gt;&gt;</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-unsigned-right-shift-operator">ES2015 12.8.5 (The Unsigned Right Shift Operator ( &gt;&gt;&gt; ))</a>.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>scalar</var> be <emu-xref aoid="ToUint32" id="_ref_283"><a href="https://tc39.github.io/ecma262/#sec-touint32">ToUint32</a></emu-xref>(<var>bits</var>).</li><li>Let <var>shiftCount</var> be <var>scalar</var> <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> (<var>SIMD</var>Descriptor.[[ElementSize]] × 8)</li><li>Let <var>result</var> be <emu-xref aoid="SIMDScalarOp" id="_ref_284"><a href="#simd-scalar">SIMDScalarOp</a></emu-xref>(<var>a</var>, <var>shiftCount</var>, <code>&gt;&gt;&gt;</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_285"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
On  <a href="#simd-signed-integer-type">signed</a> SIMD types, the following definition is used. This definition uses <code>&gt;&gt;</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-signed-right-shift-operator">ES2015 12.8.4 (The Signed Right Shift Operator ( &gt;&gt; ))</a>.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>scalar</var> be <emu-xref aoid="ToUint32" id="_ref_286"><a href="https://tc39.github.io/ecma262/#sec-touint32">ToUint32</a></emu-xref>(<var>bits</var>).</li><li>Let <var>shiftCount</var> be <var>scalar</var> <emu-xref aoid="modulo"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">modulo</a></emu-xref> (<var>SIMD</var>Descriptor.[[ElementSize]] × 8)</li><li>Let <var>result</var> be <emu-xref aoid="SIMDScalarOp" id="_ref_287"><a href="#simd-scalar">SIMDScalarOp</a></emu-xref>(<var>a</var>, <var>shiftCount</var>, <code>&gt;&gt;</code>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_288"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">The "masked" shift count semantics matches the ECMAScript scalar shift semantics.</div></emu-note>
</emu-clause>

<emu-clause id="simd-extract-lane">
<h1><span class="secnum">5.3.33</span><var>SIMD</var>Constructor.extractLane( simd, lane )</h1>
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Return <emu-xref aoid="SIMDExtractLane" id="_ref_289"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>simd</var>, <var>lane</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-replace-lane">
<h1><span class="secnum">5.3.34</span><var>SIMD</var>Constructor.replaceLane( simd, lane, value )</h1>
<emu-alg><ol><li>If <var>simd</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a TypeError exception.</li><li>Return <emu-xref aoid="SIMDReplaceLane" id="_ref_290"><a href="#simd-abstract-replace-lane">SIMDReplaceLane</a></emu-xref>(<var>simd</var>, <var>lane</var>, <var>value</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store-function">
<h1><span class="secnum">5.3.35</span><var>SIMD</var>Constructor.store( tarray, index, simd )</h1>
<p>This is defined when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>Return <emu-xref aoid="SIMDStoreInTypedArray" id="_ref_291"><a href="#simd-store-in-tarray">SIMDStoreInTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor, <var>simd</var>).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store1">
<h1><span class="secnum">5.3.36</span><var>SIMD</var>Constructor.store1( tarray, index, simd )</h1>
<p>This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4, and when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>Return <emu-xref aoid="SIMDStoreInTypedArray" id="_ref_292"><a href="#simd-store-in-tarray">SIMDStoreInTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor, <var>simd</var>, 1).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store2">
<h1><span class="secnum">5.3.37</span><var>SIMD</var>Constructor.store2( tarray, index, simd )</h1>
<p>This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4, and when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>Return <emu-xref aoid="SIMDStoreInTypedArray" id="_ref_293"><a href="#simd-store-in-tarray">SIMDStoreInTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor, <var>simd</var>, 2).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-store3">
<h1><span class="secnum">5.3.38</span><var>SIMD</var>Constructor.store3( tarray, index, simd )</h1>
<p>This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4, and when <var>SIMD</var>Descriptor has a [[SerializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>Return <emu-xref aoid="SIMDStoreInTypedArray" id="_ref_294"><a href="#simd-store-in-tarray">SIMDStoreInTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor, <var>simd</var>, 3).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load-function">
<h1><span class="secnum">5.3.39</span><var>SIMD</var>Constructor.load( tarray, index )</h1>
<p>This function is defined only on SIMD types where <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-note><span class="note">Note</span><div class="note-contents"><code>load</code> takes a TypedArray of any element type as an argument. One way to use it is to pass in a <code>Uint8Array</code> regardless of SIMD type, which is useful because it allows the compiler to eliminate the shift in going from the index to the pointer offset. Other options considered were to use an ArrayBuffer (but this is not idiomatic, to take an ArrayBuffer directly as an argument to read off of) or a DataView (but DataViews don't tend to expose platform-dependent endianness, which is important here, and they tend to use methods on <code>DataView.prototype</code>, which are harder to optimize in an asm.js context).</div></emu-note>
<emu-alg><ol><li>Return <emu-xref aoid="SIMDLoadFromTypedArray" id="_ref_295"><a href="#simd-load-from-tarray">SIMDLoadFromTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load1">
<h1><span class="secnum">5.3.40</span><var>SIMD</var>Constructor.load1(tarray, index)</h1>
<p>This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4 and <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>Return <emu-xref aoid="SIMDLoadFromTypedArray" id="_ref_296"><a href="#simd-load-from-tarray">SIMDLoadFromTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor, 1).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load2">
<h1><span class="secnum">5.3.41</span><var>SIMD</var>Constructor.load2(tarray, index)</h1>
<p>This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4 and <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>Return <emu-xref aoid="SIMDLoadFromTypedArray" id="_ref_297"><a href="#simd-load-from-tarray">SIMDLoadFromTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor, 2).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-load3">
<h1><span class="secnum">5.3.42</span><var>SIMD</var>Constructor.load3(tarray, index)</h1>
<p>This function is defined only on SIMD types where <var>SIMD</var>Descriptor.[[VectorLength]] = 4 and <var>SIMD</var>Descriptor has a [[DeserializeElement]] field.</p>

This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>Return <emu-xref aoid="SIMDLoadFromTypedArray" id="_ref_298"><a href="#simd-load-from-tarray">SIMDLoadFromTypedArray</a></emu-xref>(<var>tarray</var>, <var>index</var>, <var>SIMD</var>Descriptor, 3).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-to-timd">
<h1><span class="secnum">5.3.43</span><var>SIMD</var>Constructor.from<var>TIMD</var>Bits( value )</h1>
In this definition, <var>TIMD</var> is not <var>SIMD</var>, and <var>TIMD</var> ranges over all SIMD types for which <var>SIMD</var>Descriptor.[[ElementSize]] × <var>SIMD</var>Descriptor.[[VectorLength]] = <var>TIMD</var>Descriptor.[[ElementSize]] × <var>TIMD</var>Descriptor.[[VectorLength]], unless one descriptor does not have a [[SerializeElement]] field.

<emu-note><span class="note">Note</span><div class="note-contents">All of the SIMD types described in this spec are 16 bytes, but Booleans have no serialization, so all pairs of types which do not include Booleans are included.</div></emu-note>
<emu-alg><ol><li>If <var>value</var>.[[SIMDTypeDescriptor]] is not <var>TIMD</var>Descriptor, throw a TypeError exception.</li><li>Return <emu-xref aoid="SIMDReinterpretCast" id="_ref_299"><a href="#simd-reinterpret-cast">SIMDReinterpretCast</a></emu-xref>(<var>value</var>, <var>SIMD</var>Descriptor).</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-to-timd-logical">
<h1><span class="secnum">5.3.44</span><var>SIMD</var>Constructor.from<var>TIMD</var>( value )</h1>
In this definition, <var>TIMD</var> is not <var>SIMD</var>, <var>TIMD</var> ranges over all SIMD types for which <var>SIMD</var>Descriptor.[[VectorLength]] = <var>TIMD</var>Descriptor.[[VectorLength]], neither of <var>SIMD</var> and <var>TIMD</var> are of boolean type, and <var>SIMD</var> and <var>TIMD</var> are not both integer types.

<emu-alg><ol><li>If <var>value</var>.[[SIMDTypeDescriptor]] is not <var>TIMD</var>Descriptor, throw a TypeError exception.</li><li>Let <var>list</var> be a copy of <var>value</var>.[[SIMDElements]].</li><li>If <var>SIMD</var> is an integer type and <var>TIMD</var> is a floating point type,<ol><li>For <var>element</var> in <var>list</var>,<ol><li>If <var>element</var> is <emu-val>NaN</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>intElement</var> be <emu-xref aoid="ToInteger" id="_ref_300"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>element</var>).</li><li>If <var>intElement</var> <code>&gt;</code> <var>SIMD</var>Descriptor.[[ElementMax]] or <var>intElement</var> <code>&lt;</code> <var>SIMD</var>Descriptor.[[ElementMin]], throw a <emu-val>RangeError</emu-val> exception.</li></ol></li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_301"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>SIMD</var>Descriptor, <var>list</var>).</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">
This definition uses <code>&lt;</code> and <code>&gt;</code> to refer to the abstract operation defined by  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-relational-comparison">ES2015 7.2.11 (Abstract Relational Comparison)</a>
</div></emu-note>
</emu-clause>

<emu-clause id="swizzle">
<h1><span class="secnum">5.3.45</span><var>SIMD</var>Constructor.swizzle( a, ...lanes )</h1>
This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>indices</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>For integer <var>n</var> from <emu-val>0</emu-val> to <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Let <var>lane</var> be <var>lanes</var>[<var>i</var>], or 0 if <var>lanes</var> is not long enough.</li><li>Let <var>index</var> be <emu-xref aoid="SIMDToLane" id="_ref_302"><a href="#simd-to-lane">SIMDToLane</a></emu-xref>(<var>value</var>.[[SIMDTypeDescriptor]].[[VectorLength]], <var>lane</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_303"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>index</var>).</li><li>Append <var>index</var> to the end of <var>indices</var>.</li></ol></li><li>Let <var>fields</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>SIMD</var>Descriptor.[[VectorLength]].</li><li>For <var>i</var> in from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>Set <var>fields</var>[<var>i</var>] to <emu-xref aoid="SIMDExtractLane" id="_ref_304"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>a</var>, <var>indices</var>[<var>i</var>])</li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_305"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>SIMD</var>Descriptor, <var>fields</var>).</li></ol></emu-alg>
The <code>length</code> property of <code>_SIMD_.swizzle</code> is 1 + <var>SIMD</var>Descriptor.[[VectorLength]].

</emu-clause>

<emu-clause id="shuffle">
<h1><span class="secnum">5.3.46</span><var>SIMD</var>Constructor.shuffle( a, b, ...lanes )</h1>
This operation exists only on  <a href="#simd-integer-type">integer</a> and  <a href="#simd-floating-point-type">floating point</a> SIMD types.

<emu-alg><ol><li>If <var>a</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, or if <var>b</var>.[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>indices</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>For integer <var>n</var> from <emu-val>0</emu-val> to <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Let <var>lane</var> be <var>lanes</var>[<var>i</var>], or 0 if <var>lanes</var> is not long enough.</li><li>Let <var>index</var> be <emu-xref aoid="SIMDToLane" id="_ref_306"><a href="#simd-to-lane">SIMDToLane</a></emu-xref>(<var>SIMD</var>Descriptor.[[VectorLength]] * 2, <var>lane</var>).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_307"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>index</var>).</li><li>Append <var>index</var> to the end of <var>indices</var>.</li></ol></li><li>Let <var>fields</var> be a new <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>SIMD</var>Descriptor.[[VectorLength]].</li><li>For <var>i</var> in from 0 to <var>SIMD</var>Descriptor.[[VectorLength]] - 1,<ol><li>Let <var>idx</var> be <var>indices</var>[<var>i</var>].</li><li>If <var>idx</var> ≥ <var>SIMD</var>Descriptor.[[VectorLength]],<ol><li>Set <var>fields</var>[<var>i</var>] to <emu-xref aoid="SIMDExtractLane" id="_ref_308"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>b</var>, <var>idx</var> - <var>SIMD</var>Descriptor.[[VectorLength]])</li></ol></li><li>Otherwise,<ol><li>Set <var>fields</var>[<var>i</var>] to <emu-xref aoid="SIMDExtractLane" id="_ref_309"><a href="#simd-abstract-extract-lane">SIMDExtractLane</a></emu-xref>(<var>a</var>, <var>idx</var>)</li></ol></li></ol></li><li>Return <emu-xref aoid="SIMDCreate" id="_ref_310"><a href="#simd-create">SIMDCreate</a></emu-xref>(<var>SIMD</var>Descriptor, <var>fields</var>).</li></ol></emu-alg>
The <code>length</code> property of <code>_SIMD_.shuffle</code> is 2 + <var>SIMD</var>Descriptor.[[VectorLength]] * 2.

</emu-clause>

</emu-clause>

<emu-clause id="simd-proto">
<h1><span class="secnum">5.4</span>The <var>SIMD</var>Constructor.prototype</h1>

<emu-clause id="simd-proto-constructor">
<h1><span class="secnum">5.4.1</span><var>SIMD</var>Constructor.prototype.constructor</h1>
The initial value of <var>SIMD</var>Constructor.prototype.constructor is the intrinsic object %<var>SIMD</var>Constructor%

</emu-clause>

<emu-clause id="simd-prototype-valueof">
<h1><span class="secnum">5.4.2</span><var>SIMD</var>Constructor.prototype.valueOf()</h1>
<emu-alg><ol><li>If <emu-val>this</emu-val> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-val>this</emu-val>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-val>this</emu-val>.[[SIMDWrapperData]].</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-prototype-tolocalestring">
<h1><span class="secnum">5.4.3</span><var>SIMD</var>Constructor.prototype.toLocaleString( [ reserved1 [, reserved2 ] )</h1>
An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the <code>TypedArray.prototype.toLocaleString</code> method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the <code>toLocaleString</code> method is used.

<emu-note><span class="note">Note</span><div class="note-contents">The first and second editions of ECMA-402 did not include a replacement specification for the TypedArray.prototype.toLocaleString method.</div></emu-note>

The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.

<emu-alg><ol><li>If <emu-val>this</emu-val> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-val>this</emu-val>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>separator</var> be the String value for the list-separator String appropriate for the host environment’s current locale (this is derived in an implementation-defined way).</li><li>Let <var>list</var> be an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref></li><li>For each element <var>element</var> in <var>argument</var>.[[SIMDElements]],<ol><li>Let <var>R</var> be <emu-xref aoid="ToString" id="_ref_311"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-xref aoid="Invoke" id="_ref_312"><a href="https://tc39.github.io/ecma262/#sec-invoke">Invoke</a></emu-xref>(<var>element</var>, "toLocaleString")).</li><li><emu-xref aoid="ReturnIfAbrupt" id="_ref_313"><a href="https://tc39.github.io/ecma262/#sec-returnifabrupt">ReturnIfAbrupt</a></emu-xref>(<var>R</var>).</li><li>Append <var>R</var> to <var>list</var>.</li></ol></li><li>Let <var>results</var> be <emu-xref aoid="CreateArrayFromList" id="_ref_314"><a href="https://tc39.github.io/ecma262/#sec-createarrayfromlist">CreateArrayFromList</a></emu-xref>(<var>list</var>).</li><li>Let <var>t</var> be the string <code>"</code><var>SIMD</var><code>"</code>, e.g., <code>"Float32x4"</code>.</li><li>Let <var>e</var> be <emu-xref aoid="ArrayJoin" id="_ref_315"><a href="#array-join">ArrayJoin</a></emu-xref>(<var>results</var>, <var>separator</var>).</li><li>Return a new String value computed by concatenating the previous value of <var>t</var>, "(", <var>e</var>, and ")".</li></ol></emu-alg>
</emu-clause>

<emu-clause id="simd-prototype-tostring">
<h1><span class="secnum">5.4.4</span><var>SIMD</var>Constructor.prototype.toString()</h1>
<emu-alg><ol><li>If <emu-val>this</emu-val> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-val>this</emu-val>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid="ToString" id="_ref_316"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>(<emu-val>this</emu-val>.[[SIMDWrapperData]]).</li></ol></emu-alg>
<emu-note><span class="note">Note</span><div class="note-contents">This definition depends on the primitive <var>SIMD</var>Type's behavior under <emu-xref aoid="ToString" id="_ref_317"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref>. Alternatively, <var>SIMD</var>Type could have <emu-xref aoid="ToString" id="_ref_318"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref> defined by calling <emu-xref aoid="ToObject" id="_ref_319"><a href="https://tc39.github.io/ecma262/#sec-toobject">ToObject</a></emu-xref> and then reaching this method (or whatever the user overrides it with), in which case the current definition in <emu-xref aoid="ToString" id="_ref_320"><a href="https://tc39.github.io/ecma262/#sec-tostring">ToString</a></emu-xref> would be brought down here.</div></emu-note>
</emu-clause>

<emu-clause id="simd-to-string-tag">
<h1><span class="secnum">5.4.5</span><var>SIMD</var>Constructor.prototype [ @@toStringTag ]</h1>
<p>The initial value of the @@toStringTag property is the String value <code>"SIMD.</code><var>SIMD</var><code>"</code>, e.g., <code>"SIMD.Float32x4"</code>.</p>

This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.

</emu-clause>

<emu-clause id="simd-to-primitive">
<h1><span class="secnum">5.4.6</span><var>SIMD</var>Constructor.prototype [ @@toPrimitive ] ( hint )</h1>
<emu-note><span class="note">Note</span><div class="note-contents">
This function is called by ECMAScript language operators to convert a Symbol object to a primitive value. The allowed values for hint are <code>"default"</code>, <code>"number"</code>, and <code>"string"</code>.

</div></emu-note>

When the <code>@@toPrimitive</code> method is called with argument <var>hint</var>, the following steps are taken:

<emu-alg><ol><li>Let <var>s</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type" id="_ref_321"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>s</var>) is a SIMD type, return <var>s</var>.</li><li>If <emu-xref aoid="Type" id="_ref_322"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>s</var>) is not <code>Object</code>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>s</var> does not have a [[SIMDWrapperData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>s</var>.[[SIMDWrapperData]].[[SIMDTypeDescriptor]] is not <var>SIMD</var>Descriptor, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return the value of <var>s</var>’s [[SIMDWrapperData]] internal slot.</li></ol></emu-alg>

<p>The value of the <code>name</code> property of this function is <code>"[Symbol.toPrimitive]"</code>.</p>

This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.

</emu-clause>

</emu-clause>

<emu-clause id="simd-descriptors">
<h1><span class="secnum">5.5</span>SIMD type descriptors</h1>
<p>This section describes the SIMD type descriptors, which are organized as described in the %SIMD% section. The following internal algorithms support the definition of the SIMD types.</p>

In the internal algorithms in this section, preceding the first step, if <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time one of the following algorithms is executed, and it must be consistent across all algorithms.

<emu-clause id="serialize-float32" aoid="SerializeFloat32">
<h1><span class="secnum">5.5.1</span>SerializeFloat32( block, offset, n, isLittleEndian )</h1>
<emu-note><span class="note">Note</span><div class="note-contents">Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-setvalueinbuffer">SetValueInBuffer</a>. Note that this specification does not require a particular bit pattern for <emu-val>NaN</emu-val>, and that it does not need to be the same across calls.</div></emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>n</var> is a number.</li><li>Assert: <var>offset</var> + 4 is less than or equal to the size of <var>block</var>.</li><li>Set <var>rawBytes</var> to a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the 4 bytes that are the result of converting value to IEEE 754-2008 binary32 format using “Round to nearest, ties to even” rounding mode. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If value is <emu-val>NaN</emu-val>, <var>rawValue</var> may be set to any implementation chosen <emu-val>NaN</emu-val> encoding. An implementation must always choose the same <emu-val>NaN</emu-val> encoding for a distinct Not-a-Number value.</li><li>Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>offset</var>].</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-float32" aoid="DeserializeFloat32">
<h1><span class="secnum">5.5.2</span>DeserializeFloat32( block, offset, isLittleEndian )</h1>
<emu-note><span class="note">Note</span><div class="note-contents">Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getvaluefrombuffer">GetValueFromBuffer</a>. Note that while this says to return "the <emu-val>NaN</emu-val> value", the binary representation is not observable and canonicalization is not required.</div></emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>offset</var> + 4 is less than or equal to the size of <var>block</var>.</li><li>Let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of 4 containing, in order, the sequence of 4 bytes starting with <var>block</var>[<var>offset</var>].</li><li>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawValue</var>.</li><li>Let <var>value</var> be the byte elements of rawValue concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.</li><li>If <var>value</var> is an IEEE 754-2008 binary32 <emu-val>NaN</emu-val> value, return the <emu-val>NaN</emu-val> Number value.</li><li>Return the Number value that corresponds to <var>value</var>.</li></ol></emu-alg>
</emu-clause>

<emu-clause id="serialize-int" aoid="SerializeInt">
<h1><span class="secnum">5.5.3</span>SerializeInt( descriptor )( block, offset, n, isLittleEndian )</h1>
<emu-note><span class="note">Note</span><div class="note-contents">Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-setvalueinbuffer">SetValueInBuffer</a>.</div></emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>n</var> is a number.</li><li>Assert: <var>n</var> = <var>descriptor</var>.[[Cast]](<var>n</var>).</li><li>Assert: <var>offset</var> + <var>descriptor</var>.[[ElementSize]] is less than or equal to the size of <var>block</var>.</li><li>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the <var>descriptor</var>.[[ElementSize]]-byte binary 2’s complement encoding of <var>n</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</li><li>Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>offset</var>].</li></ol></emu-alg>
</emu-clause>

<emu-clause id="deserialize-int" aoid="DeserializeInt">
<h1><span class="secnum">5.5.4</span>DeserializeInt( descriptor )( block, offset, isLittleEndian )</h1>
<emu-note><span class="note">Note</span><div class="note-contents">Derived from part of  <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-getvaluefrombuffer">GetValueFromBuffer</a>.</div></emu-note>
<emu-alg><ol><li>Assert: <var>block</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref>.</li><li>Assert: <var>offset</var> is a number.</li><li>Assert: <var>offset</var> + <var>descriptor</var>.[[ElementSize]] is less than or equal to the size of <var>block</var>.</li><li>Let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <var>descriptor</var>.[[ElementSize]] containing, in order, the sequence of <var>descriptor</var>.[[ElementSize]] bytes starting with <var>block</var>[<var>offset</var>].</li><li>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawValue</var>.</li><li>Let <var>intValue</var> be the byte elements of <var>rawValue</var> concatenated and interpreted as a bit string encoding of an integer of bit length <var>descriptor</var>.[[ElementSize]] × 8. If <var>descriptor</var> is a signed type, interpret as signed 2's complement; if it is unsigned, interpret as an unsigned integer.</li><li>Return the Number value that corresponds to <var>intValue</var>.</li></ol></emu-alg>
</emu-clause>

<emu-table id="simd-descriptor-table"><figure><figcaption>Table 3: SIMD type descriptors</figcaption>

<table class="real-table">
<tbody><tr>
<th>Name</th>
<th>Kind of <emu-xref aoid="SIMD value" id="_ref_323"><a href="#simd-value-def">SIMD value</a></emu-xref></th>
<th>[[VectorLength]]</th>
<th>[[ElementSize]]</th>
<th>[[Cast]]</th>
<th>[[SerializeElement]]</th>
<th>[[DeserializeElement]]</th>
<th>[[ElementMax]]</th>
<th>[[ElementMin]]</th>
</tr>

<tr>
<td><emu-xref aoid="Float32x4" id="_ref_324"><a href="#float32x4">Float32x4</a></emu-xref></td>
<td><a href="#simd-floating-point-type">floating-point</a></td>
<td>4</td>
<td>4</td>
<td><emu-xref aoid="ToFloat32" id="_ref_325"><a href="#fround">ToFloat32</a></emu-xref></td>
<td><emu-xref aoid="SerializeFloat32" id="_ref_326"><a href="#serialize-float32">SerializeFloat32</a></emu-xref></td>
<td><emu-xref aoid="DeserializeFloat32" id="_ref_327"><a href="#deserialize-float32">DeserializeFloat32</a></emu-xref></td>
<td></td>
<td></td>
</tr>

<tr>
<td><emu-xref aoid="Int32x4" id="_ref_328"><a href="#int32x4">Int32x4</a></emu-xref></td>
<td><a href="#simd-signed-integer-type">signed integer</a></td>
<td>4</td>
<td>4</td>
<td><emu-xref aoid="ToInt32" id="_ref_329"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref></td>
<td><emu-xref aoid="SerializeInt" id="_ref_330"><a href="#serialize-int">SerializeInt</a></emu-xref>(Int32x4Descriptor)</td>
<td><emu-xref aoid="DeserializeInt" id="_ref_331"><a href="#deserialize-int">DeserializeInt</a></emu-xref>(Int32x4Descriptor)</td>
<td>2<sup>31</sup>-1</td>
<td>-2<sup>31</sup></td>
</tr>

<tr>
<td><emu-xref aoid="Int16x8" id="_ref_332"><a href="#int16x8">Int16x8</a></emu-xref></td>
<td><a href="#simd-signed-integer-type">signed integer</a></td>
<td>8</td>
<td>2</td>
<td><emu-xref aoid="ToInt16" id="_ref_333"><a href="https://tc39.github.io/ecma262/#sec-toint16">ToInt16</a></emu-xref></td>
<td><emu-xref aoid="SerializeInt" id="_ref_334"><a href="#serialize-int">SerializeInt</a></emu-xref>(Int16x8Descriptor)</td>
<td><emu-xref aoid="DeserializeInt" id="_ref_335"><a href="#deserialize-int">DeserializeInt</a></emu-xref>(Int16x8Descriptor)</td>
<td>2<sup>15</sup>-1</td>
<td>-2<sup>15</sup></td>
</tr>

<tr>
<td><emu-xref aoid="Int8x16" id="_ref_336"><a href="#int8x16">Int8x16</a></emu-xref></td>
<td><a href="#simd-signed-integer-type">signed integer</a></td>
<td>16</td>
<td>1</td>
<td><emu-xref aoid="ToInt8" id="_ref_337"><a href="https://tc39.github.io/ecma262/#sec-toint8">ToInt8</a></emu-xref></td>
<td><emu-xref aoid="SerializeInt" id="_ref_338"><a href="#serialize-int">SerializeInt</a></emu-xref>(Int8x16Descriptor)</td>
<td><emu-xref aoid="DeserializeInt" id="_ref_339"><a href="#deserialize-int">DeserializeInt</a></emu-xref>(Int8x16Descriptor)</td>
<td>127</td>
<td>-128</td>
</tr>

<tr>
<td><emu-xref aoid="Uint32x4" id="_ref_340"><a href="#uint32x4">Uint32x4</a></emu-xref></td>
<td><a href="#simd-unsigned-integer-type">unsigned integer</a></td>
<td>4</td>
<td>4</td>
<td><emu-xref aoid="ToUint32" id="_ref_341"><a href="https://tc39.github.io/ecma262/#sec-touint32">ToUint32</a></emu-xref></td>
<td><emu-xref aoid="SerializeInt" id="_ref_342"><a href="#serialize-int">SerializeInt</a></emu-xref>(Uint32x4Descriptor)</td>
<td><emu-xref aoid="DeserializeInt" id="_ref_343"><a href="#deserialize-int">DeserializeInt</a></emu-xref>(Uint32x4Descriptor)</td>
<td>2<sup>32</sup>-1</td>
<td>0</td>
</tr>

<tr>
<td><emu-xref aoid="Uint16x8" id="_ref_344"><a href="#uint16x8">Uint16x8</a></emu-xref></td>
<td><a href="#simd-unsigned-integer-type">unsigned integer</a></td>
<td>8</td>
<td>2</td>
<td><emu-xref aoid="ToUint16" id="_ref_345"><a href="https://tc39.github.io/ecma262/#sec-touint16">ToUint16</a></emu-xref></td>
<td><emu-xref aoid="SerializeInt" id="_ref_346"><a href="#serialize-int">SerializeInt</a></emu-xref>(Uint16x8Descriptor)</td>
<td><emu-xref aoid="DeserializeInt" id="_ref_347"><a href="#deserialize-int">DeserializeInt</a></emu-xref>(Uint16x8Descriptor)</td>
<td>2<sup>16</sup>-1</td>
<td>0</td>
</tr>

<tr>
<td><emu-xref aoid="Uint8x16" id="_ref_348"><a href="#uint8x16">Uint8x16</a></emu-xref></td>
<td><a href="#simd-unsigned-integer-type">unsigned integer</a></td>
<td>16</td>
<td>1</td>
<td><emu-xref aoid="ToUint8" id="_ref_349"><a href="https://tc39.github.io/ecma262/#sec-touint8">ToUint8</a></emu-xref></td>
<td><emu-xref aoid="SerializeInt" id="_ref_350"><a href="#serialize-int">SerializeInt</a></emu-xref>(Uint8x16Descriptor)</td>
<td><emu-xref aoid="DeserializeInt" id="_ref_351"><a href="#deserialize-int">DeserializeInt</a></emu-xref>(Uint8x16Descriptor)</td>
<td>255</td>
<td>0</td>
</tr>

<tr>
<td><emu-xref aoid="Bool32x4" id="_ref_352"><a href="#bool32x4">Bool32x4</a></emu-xref></td>
<td><a href="#simd-boolean-type">boolean</a></td>
<td>4</td>
<td></td>
<td><emu-xref aoid="ToBoolean" id="_ref_353"><a href="https://tc39.github.io/ecma262/#sec-toboolean">ToBoolean</a></emu-xref></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td><emu-xref aoid="Bool16x8" id="_ref_354"><a href="#bool16x8">Bool16x8</a></emu-xref></td>
<td><a href="#simd-boolean-type">boolean</a></td>
<td>8</td>
<td></td>
<td><emu-xref aoid="ToBoolean" id="_ref_355"><a href="https://tc39.github.io/ecma262/#sec-toboolean">ToBoolean</a></emu-xref></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>

<tr>
<td><emu-xref aoid="Bool8x16" id="_ref_356"><a href="#bool8x16">Bool8x16</a></emu-xref></td>
<td><a href="#simd-boolean-type">boolean</a></td>
<td>16</td>
<td></td>
<td><emu-xref aoid="ToBoolean" id="_ref_357"><a href="https://tc39.github.io/ecma262/#sec-toboolean">ToBoolean</a></emu-xref></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</figure></emu-table>

</emu-clause>
</emu-clause>
</div></body>